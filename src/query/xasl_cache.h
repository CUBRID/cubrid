/*
 * Copyright (C) 2008 Search Solution Corporation. All rights reserved by Search Solution.
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *
 */

/*
 * XASL cache.
 */

#ifndef _XASL_CACHE_H_
#define _XASL_CACHE_H_

#ident "$Id$"

#include "query_list.h"
#include "query_opfunc.h"

/* TODO: Remove me. */
typedef struct xasl_qstr_ht_key XASL_QSTR_HT_KEY;
struct xasl_qstr_ht_key
{
  const char *query_string;
  OID creator_oid;		/* OID of the user who created this XASL */
};

/* This really belongs more to the query manager rather than query executor. */
/* XASL cache entry type definition */
typedef struct xasl_cache_ent XASL_CACHE_ENTRY;
struct xasl_cache_ent
{
  XASL_ID xasl_id;		/* XASL file identifier */
				/* Not really a file identifier anymore. Maybe we should rename this to XASL_KEY? */
  
  /* Latch-free stuff. */
  XASL_CACHE_ENTRY *stack;	/* used in freelist */
  XASL_CACHE_ENTRY *next;	/* used in hash table */
  /* Mutex may be addex here (hopefully it is not necessary). */
  UINT64 del_id;		/* delete transaction ID (for lock free) */


  EXECUTION_INFO sql_info;	/* cache entry hash key, user input string & plan */
  int xasl_header_flag;		/* XASL header info */
#if defined(SERVER_MODE)
  char *tran_fix_count_array;	/* fix count of each transaction; size is MAX_NTRANS */
  int num_fixed_tran;		/* number of transactions fixed this entry */
  int num_pinned_tran;		/* number of transactions pinned this entry */
  XASL_CACHE_ENTRY *prev_pinned_ent;	/* the prev pointer of poinned cache entry */
  XASL_CACHE_ENTRY *next_pinned_ent;	/* the next pointer of poinned cache entry */
#endif
  const OID *class_oid_list;	/* list of class/serial OIDs referenced in the XASL */
  const int *class_locks;	/* Class locks */
  const int *tcard_list;	/* list of #pages of the class OIDs */
  struct timeval time_created;	/* when this entry created */
  struct timeval time_last_used;	/* when this entry used lastly */
  int n_oid_list;		/* size of the class OID list */
  int ref_count;		/* how many times this entry used */
  int dbval_cnt;		/* number of DB_VALUE parameters of the XASL */
  int list_ht_no;		/* memory hash table for query result(list file) cache generated by this XASL
				 * referencing by DB_VALUE parameters bound to the result */
  struct xasl_cache_clo *clo_list;	/* list of cache clones for this XASL */
  bool deletion_marker;		/* this entry will be deleted if marker set */
  XASL_QSTR_HT_KEY qstr_ht_key;	/* The key of query string hash table */
  HENTRY_PTR qstr_ht_entry_ptr;	/* Hash entry of the query string hash table that holds this xasl cache entry. This
				 * pointer is used to update query string hash table's lru list. */
};

/* XASL cache clone type definition */
/* TODO: Remove me? */
typedef struct xasl_cache_clo XASL_CACHE_CLONE;
struct xasl_cache_clo
{
  XASL_CACHE_CLONE *next;
  XASL_CACHE_CLONE *LRU_prev;
  XASL_CACHE_CLONE *LRU_next;
  XASL_CACHE_ENTRY *ent_ptr;	/* cache entry pointer */
  void *xasl;			/* XASL or PRED_EXPR_WITH_CONTEXT tree root pointer */
  void *xasl_buf_info;		/* XASL tree buffer info */
};

extern int xcache_initialize (void);
extern void xcache_finalize (void);

extern int xcache_find_sha1 (THREAD_ENTRY * thread_p, SHA1Hash * sha1, XASL_CACHE_ENTRY ** xcache_entry);
extern int xcache_find_xasl_id (THREAD_ENTRY * thread_p, XASL_ID * xid, XASL_CACHE_ENTRY ** xcache_entry);
extern int xcache_entry_decrement_read_counter (THREAD_ENTRY * thread_p, XASL_CACHE_ENTRY * xcache_entry);
extern int xcache_find_or_insert (THREAD_ENTRY * thread_p, SHA1Hash * sha1, XASL_STREAM * stream, const OID * oid,
				  int n_oid, const OID * class_oids, const int * class_locks, const int *tcards,
				  int dbval_cnt, XASL_CACHE_ENTRY ** xcache_entry);
extern int xcache_remove_by_oid (THREAD_ENTRY * thread_p, OID * oid);

#endif /* _XASL_CACHE_H_ */
