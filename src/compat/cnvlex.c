/*
 * Copyright 2008 Search Solution Corporation
 * Copyright 2016 CUBRID Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */


/*
 * cnvlex.c - A lexical scanner generated by flex
 */

#ident "$Id$"

#define FLEX_SCANNER

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
#if 0
#include <osfcn.h>
#endif

/* use prototypes in function declarations */
#define YY_USE_PROTOS

/* the "const" storage-class-modifier is valid */
#define YY_USE_CONST

#else /* ! __cplusplus */

#if defined(__STDC__) || defined(WINDOWS)

#ifdef __GNUC__
#include <stddef.h>
void *malloc (size_t);
void free (void *);
#else
#include <stdlib.h>
#endif /* __GNUC__ */

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif /* __STDC__ */
#endif /* ! __cplusplus */


#ifdef __TURBOC__
#define YY_USE_CONST
#endif


#ifndef YY_USE_CONST
#define const
#endif

#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#endif

/* amount of stuff to slurp up with each read */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* returned upon end-of-file */
#define YY_END_TOK 0

/* copy whatever the last rule matched to the standard output */

/* cast to (char *) is because for 8-bit chars, yytext is (unsigned char *) */
/* this used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite()
 */
#define ECHO (void) fwrite( (char *) yytext, yyleng, 1, yyout )

/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#define YY_INPUT(buf,result,max_size) \
	if ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
	    YY_FATAL_ERROR( "read() in flex scanner failed" );
#define YY_NULL 0

/* no semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#define yyterminate() return ( (FMT_TOKEN_TYPE) YY_NULL )

/* report a fatal error */

#define YY_FATAL_ERROR(msg) \
	do                  \
          {                 \
		(void) fputs( msg, stderr ); \
		(void) putc( '\n', stderr ); \
		exit( 1 );  \
	  }                 \
	while ( 0 )

/* default yywrap function - always treat EOF as an EOF */
#define yywrap() 1

/* enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN
 */
#define BEGIN yy_start = 1 + 2 *

/* action number for EOF rule of a given start state */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* special action meaning "start processing a new file" */
#define YY_NEW_FILE \
	do          \
	  {         \
		yy_init_buffer( yy_current_buffer, yyin ); \
		yy_load_buffer_state();                    \
	  }         \
	while ( 0 )

/* default declaration of generated scanner - a define so the user can
 * easily add parameters
 */
#define YY_DECL int yylex YY_PROTO(( void ))

/* code executed at the end of each rule */
#define YY_BREAK break;

#define YY_END_OF_BUFFER_CHAR 0

#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2)	/* size of default input buffer */
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;

#define YY_CHAR unsigned char
#define INITIAL 0

#include <stdlib.h>
#include <assert.h>
#include "config.h"

/* Set up custom prefix */
#undef YY_PREFIX
#define YY_PREFIX dbcnv
#include "cnvlex.h"
#include "util_func.h"

static int cnv_fmt_lex_start (FMT_LEX_MODE mode);

/* Global variables */
static int cnv_fmt__init = 0;
static const char *cnv_fmt__input = NULL;
static const char *cnv_fmt__next = NULL;
static int cnv_fmt__unlex = 0;
static FMT_LEX_MODE cnv_fmt__mode = FL_LOCAL_NUMBER;

#undef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 512

#undef YY_DECL
#define YY_DECL \
FMT_TOKEN_TYPE cnv_fmt_lex( FMT_TOKEN *token)

#undef YY_INPUT
#define YY_INPUT( buf, result, max) \
result = (*(buf) = *cnv_fmt__input)? (cnv_fmt__input++, 1) : YY_NULL;

#undef YY_USER_ACTION
#define YY_USER_ACTION \
token->text   = token->raw_text = (const char *)yytext; \
token->length = yyleng;

#undef YY_USER_INIT
#define YY_USER_INIT \
if( !cnv_fmt__init) { \
  atexit( cnv_fmt_exit); \
  cnv_fmt__init = 1; \
  } \
BEGIN( cnv_fmt_lex_start( cnv_fmt__mode));


#define DB_FMT_LEX_RETURN( t) \
token->type   = t; \
cnv_fmt__next  += yyleng; \
return t;

#define SC_US_ENG_NUMBER 1
#define SC_KO_KR_NUMBER 3
#define SC_US_ENG_TIME 4
#define SC_KO_KR_TIME 6
#define SC_BIT_STRING 7
#define SC_INTEGER_FORMAT 8
#define SC_TIME_FORMAT 9
#define SC_BIT_STRING_FORMAT 10
#define SC_VALIDATE_DATE_FORMAT 11
#define SC_VALIDATE_FLOAT_FORMAT 12
#define SC_VALIDATE_INTEGER_FORMAT 13
#define SC_VALIDATE_MONETARY_FORMAT 14
#define SC_VALIDATE_TIME_FORMAT 15
#define SC_VALIDATE_TIMESTAMP_FORMAT 16
#define SC_VALIDATE_BIT_STRING_FORMAT 17

/*
 * These macros should allow users to build scanners that export global
 * symbols with the user's choice of prefix other than "yy".
 * This is mandatory if more than one scanner is being used in a piece
 * of software.
 */
#ifndef YY_PREFIX
#define YY_PREFIX yy
#endif
#define YY_RENAME(a)    YY_GLUE(YY_PREFIX,a)
#define YY_GLUE(a,b)    a ## b


#define yy_create_buffer        YY_RENAME(create_buffer)
#define yy_delete_buffer        YY_RENAME(delete_buffer)
#define yy_init_buffer          YY_RENAME(init_buffer)
#define yy_load_buffer_state    YY_RENAME(load_buffer_state)
#define yy_switch_to_buffer     YY_RENAME(switch_to_buffer)
#define yy_empty_file           YY_RENAME(empty_file)
#define yyin                    YY_RENAME(in)
#define yyleng                  YY_RENAME(leng)
#define yyout                   YY_RENAME(out)
#define yyrestart               YY_RENAME(restart)
#define yytext                  YY_RENAME(text)
#define yyunput                 YY_RENAME(unput)
#define yy_flex_debug           YY_RENAME(flex_debug)
#define yylex                   YY_RENAME(lex)


/* done after the current pattern has been matched and before the
 * corresponding action - sets up yytext
 */
#define YY_DO_BEFORE_ACTION \
	yytext = yy_bp; \
	yyleng = (int)(yy_cp - yy_bp); \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* return all but the first 'n' matched characters back to the input stream */
#define yyless(n) \
	do        \
          {       \
		/* undo effects of setting up yytext */ \
		*yy_cp = yy_hold_char;                  \
		yy_c_buf_p = yy_cp = yy_bp + n;         \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
          }       \
	while ( 0 )

#define unput(c) yyunput( c, yytext )


struct yy_buffer_state
{
  FILE *yy_input_file;

  YY_CHAR *yy_ch_buf;		/* input buffer */
  YY_CHAR *yy_buf_pos;		/* current position in input buffer */

  /* size of input buffer in bytes, not including room for EOB characters */
  int yy_buf_size;

  /* number of characters read into yy_ch_buf, not including EOB characters */
  int yy_n_chars;

  int yy_eof_status;		/* whether we've seen an EOF on this buffer */
#define EOF_NOT_SEEN 0
  /* "pending" happens when the EOF has been seen but there's still some text process */
#define EOF_PENDING 1
#define EOF_DONE 2
};

static YY_BUFFER_STATE yy_current_buffer;

/* we provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state"
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed */
static YY_CHAR yy_hold_char;

static int yy_n_chars;		/* number of characters read into yy_ch_buf */



#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

#ifndef YY_USER_INIT
#define YY_USER_INIT
#endif

YY_CHAR *yytext;
int yyleng;
FILE *yyin, *yyout;

#define YY_END_OF_BUFFER 98
typedef int yy_state_type;
static const short int yy_accept[353] = { 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 84, 84, 0, 0, 0, 0,
  0, 0, 74, 74, 75, 75, 76, 76, 78, 78,
  79, 79, 80, 80, 0, 0, 98, 95, 97, 4,
  8, 2, 95, 1, 3, 9, 7, 5, 95, 95,
  14, 13, 13, 15, 95, 95, 95, 95, 95, 95,
  95, 95, 95, 95, 95, 95, 95, 95, 95, 95,
  95, 84, 85, 58, 58, 57, 95, 60, 60, 95,
  95, 95, 97, 95, 75, 75, 75, 75, 75, 95,
  97, 76, 76, 76, 77, 76, 95, 78, 78, 78,

  78, 78, 95, 97, 95, 95, 97, 95, 95, 8,
  0, 9, 0, 7, 5, 11, 10, 12, 17, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  18, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 16, 0, 84, 85, 58, 57,
  59, 60, 61, 66, 64, 73, 62, 67, 68, 72,
  69, 63, 71, 65, 70, 82, 83, 0, 0, 74,
  75, 75, 75, 75, 75, 75, 75, 75, 75, 75,
  75, 75, 75, 0, 77, 0, 76, 76, 76, 76,
  76, 76, 76, 77, 0, 76, 76, 78, 78, 78,

  78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
  78, 78, 0, 0, 79, 0, 0, 80, 80, 81,
  0, 13, 48, 52, 56, 46, 31, 45, 51, 50,
  47, 37, 27, 55, 54, 32, 53, 26, 30, 28,
  29, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  74, 75, 75, 75, 76, 76, 76, 78, 78, 78,
  78, 78, 78, 78, 78, 78, 78, 78, 78, 79,
  80, 6, 0, 0, 0, 0, 0, 0, 39, 38,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  93, 92, 91, 89, 88, 94, 90, 86, 87, 78,

  78, 78, 36, 0, 0, 0, 0, 0, 35, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 40, 0,
  0, 24, 0, 20, 0, 0, 0, 0, 19, 0,
  0, 0, 0, 0, 33, 0, 42, 0, 0, 0,
  21, 0, 44, 34, 43, 25, 0, 23, 0, 41,
  22, 0
};

static const YY_CHAR yy_ec[256] = { 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 3, 1, 1, 1, 4, 5, 1, 1, 6,
  7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
  16, 16, 16, 16, 16, 16, 17, 18, 1, 1,
  1, 1, 1, 1, 19, 20, 21, 22, 23, 24,
  1, 25, 26, 27, 1, 1, 28, 29, 30, 31,
  1, 32, 33, 34, 1, 1, 35, 36, 37, 38,
  1, 39, 1, 1, 1, 1, 40, 41, 42, 43,

  44, 45, 46, 47, 48, 1, 26, 49, 50, 51,
  52, 53, 1, 54, 55, 56, 57, 58, 59, 60,
  61, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 62, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 63, 1, 1, 1, 64, 1, 65, 1,
  1, 1, 1, 66, 1, 1, 1, 67, 1, 1,
  68, 69, 1, 1, 1, 70, 71, 1, 1, 72,

  1, 1, 1, 1, 1, 1, 73, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 74,
  75, 1, 1, 1, 1, 76, 1, 77, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  78, 1, 1, 1, 1, 79, 1, 1, 80, 1,
  1, 81, 1, 1, 1
};

static const YY_CHAR yy_meta[82] = { 0,
  1, 1, 1, 1, 2, 1, 1, 1, 1, 1,
  1, 1, 1, 3, 3, 3, 3, 1, 4, 4,
  5, 4, 4, 3, 6, 6, 1, 6, 1, 1,
  1, 6, 6, 6, 1, 7, 8, 6, 9, 4,
  4, 5, 4, 4, 3, 1, 1, 1, 6, 8,
  1, 1, 6, 6, 1, 1, 1, 1, 8, 8,
  8, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1
};

static const short int yy_base[373] = { 0,
  0, 16, 32, 48, 869, 868, 59, 70, 131, 0,
  86, 109, 172, 189, 257, 0, 81, 92, 1, 17,
  33, 49, 88, 90, 206, 208, 134, 192, 230, 231,
  103, 105, 111, 113, 133, 135, 869, 872, 872, 872,
  860, 872, 165, 872, 872, 853, 182, 872, 792, 235,
  872, 246, 250, 872, 254, 821, 1, 57, 89, 812,
  821, 834, 112, 49, 817, 810, 809, 219, 782, 50,
  784, 153, 0, 0, 0, 820, 819, 0, 0, 307,
  317, 849, 848, 0, 214, 296, 267, 304, 217, 118,
  217, 284, 346, 279, 267, 336, 816, 361, 379, 384,

  386, 390, 846, 845, 381, 844, 843, 842, 400, 838,
  423, 831, 428, 434, 872, 872, 872, 438, 872, 790,
  797, 800, 800, 792, 788, 162, 122, 787, 779, 780,
  872, 779, 781, 782, 775, 787, 787, 754, 750, 748,
  746, 752, 747, 760, 872, 283, 295, 0, 0, 786,
  872, 0, 872, 872, 872, 872, 872, 872, 872, 872,
  872, 872, 872, 872, 872, 872, 872, 816, 0, 815,
  368, 385, 448, 400, 307, 419, 811, 801, 779, 319,
  353, 1, 181, 323, 382, 780, 387, 425, 458, 452,
  436, 441, 442, 388, 779, 446, 451, 488, 475, 489,

  483, 872, 459, 499, 500, 501, 49, 232, 498, 508,
  510, 512, 809, 521, 808, 807, 806, 805, 804, 872,
  513, 517, 760, 750, 762, 751, 761, 746, 741, 757,
  758, 872, 756, 754, 745, 739, 739, 751, 739, 737,
  740, 783, 782, 781, 780, 779, 778, 777, 702, 712,
  776, 511, 399, 506, 527, 522, 504, 529, 544, 772,
  730, 670, 548, 550, 533, 539, 560, 569, 572, 702,
  701, 872, 655, 631, 633, 552, 568, 567, 872, 872,
  559, 565, 554, 562, 548, 557, 560, 544, 555, 553,
  872, 872, 872, 872, 872, 872, 872, 872, 872, 570,

  568, 557, 872, 540, 553, 553, 531, 537, 872, 529,
  548, 544, 544, 533, 518, 493, 439, 421, 872, 429,
  416, 872, 371, 872, 360, 327, 339, 330, 872, 298,
  264, 252, 239, 184, 872, 167, 872, 151, 133, 102,
  872, 99, 872, 872, 872, 872, 37, 872, 16, 872,
  872, 872, 610, 619, 628, 637, 646, 655, 664, 671,
  676, 684, 693, 701, 709, 718, 727, 736, 744, 752,
  761, 770
};

static const short int yy_def[373] = { 0,
  353, 353, 353, 353, 353, 353, 353, 353, 353, 9,
  353, 353, 353, 353, 353, 15, 354, 354, 355, 355,
  353, 353, 356, 356, 353, 353, 357, 357, 353, 353,
  358, 358, 359, 359, 353, 353, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 360, 360, 361, 361, 352, 352, 362, 362, 352,
  352, 363, 363, 364, 352, 352, 352, 352, 352, 365,
  365, 365, 365, 365, 366, 365, 352, 352, 352, 352,

  352, 352, 367, 367, 352, 368, 368, 369, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 360, 360, 361, 352,
  352, 362, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 363, 364, 370,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 365, 366, 352, 365, 365, 365, 365,
  365, 365, 365, 366, 352, 365, 365, 352, 352, 352,

  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 367, 352, 371, 368, 369, 372, 372, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  370, 352, 352, 352, 365, 365, 365, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 371,
  372, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,

  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 0, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352
};

static const short int yy_nxt[954] = { 0,
  352, 39, 79, 40, 352, 80, 352, 41, 42, 43,
  44, 45, 173, 46, 47, 47, 47, 39, 79, 40,
  352, 80, 352, 41, 42, 43, 44, 45, 352, 46,
  47, 47, 47, 39, 39, 40, 352, 81, 254, 41,
  42, 43, 44, 45, 123, 46, 47, 47, 47, 39,
  39, 40, 202, 81, 124, 41, 42, 43, 44, 45,
  39, 46, 47, 47, 47, 207, 41, 42, 43, 44,
  45, 39, 46, 47, 47, 47, 351, 41, 42, 43,
  44, 45, 75, 46, 47, 47, 47, 39, 50, 83,
  350, 83, 84, 75, 84, 135, 125, 48, 51, 52,

  53, 53, 53, 54, 104, 136, 104, 105, 48, 105,
  39, 50, 107, 126, 107, 108, 76, 108, 146, 77,
  49, 51, 52, 53, 53, 53, 54, 76, 127, 145,
  77, 49, 39, 50, 39, 91, 39, 109, 349, 109,
  128, 92, 93, 51, 52, 53, 53, 53, 54, 55,
  94, 132, 56, 185, 57, 133, 186, 58, 59, 60,
  61, 62, 348, 63, 64, 65, 147, 147, 134, 95,
  66, 96, 97, 39, 50, 231, 347, 68, 111, 111,
  111, 111, 232, 67, 51, 52, 53, 53, 53, 54,
  39, 50, 173, 91, 68, 113, 114, 114, 114, 92,

  93, 51, 52, 53, 53, 53, 54, 39, 94, 39,
  229, 346, 230, 85, 86, 85, 86, 87, 183, 87,
  345, 171, 88, 172, 88, 173, 182, 95, 173, 96,
  97, 39, 39, 98, 98, 202, 69, 99, 99, 70,
  71, 100, 100, 89, 344, 89, 101, 101, 116, 116,
  116, 116, 185, 69, 183, 186, 70, 71, 39, 117,
  117, 117, 117, 118, 118, 118, 118, 102, 102, 208,
  72, 72, 73, 73, 177, 73, 73, 73, 73, 73,
  73, 119, 138, 178, 139, 140, 141, 142, 192, 143,
  144, 187, 343, 188, 342, 193, 73, 73, 73, 73,

  73, 73, 185, 174, 179, 195, 120, 173, 147, 147,
  121, 153, 175, 180, 185, 173, 180, 186, 173, 185,
  181, 166, 186, 181, 341, 154, 155, 156, 157, 157,
  173, 158, 158, 176, 159, 253, 166, 340, 160, 161,
  160, 167, 160, 162, 163, 196, 154, 155, 156, 164,
  164, 249, 167, 189, 250, 158, 155, 166, 185, 165,
  160, 186, 190, 167, 173, 154, 157, 162, 198, 181,
  339, 185, 199, 197, 186, 171, 167, 200, 338, 173,
  337, 185, 202, 191, 186, 215, 203, 202, 204, 202,
  205, 206, 252, 202, 187, 209, 173, 205, 201, 211,

  207, 205, 210, 336, 220, 215, 215, 171, 215, 172,
  173, 173, 215, 215, 215, 253, 215, 185, 215, 220,
  195, 208, 185, 185, 220, 186, 195, 212, 182, 215,
  173, 335, 255, 215, 215, 220, 221, 221, 221, 221,
  220, 113, 114, 114, 114, 196, 220, 113, 114, 114,
  114, 222, 222, 222, 222, 177, 183, 256, 193, 220,
  185, 192, 202, 186, 178, 187, 203, 188, 193, 334,
  205, 185, 333, 197, 186, 332, 185, 185, 331, 186,
  186, 185, 260, 257, 186, 179, 185, 185, 197, 186,
  186, 261, 265, 185, 199, 258, 186, 259, 263, 199,

  199, 202, 202, 202, 202, 264, 267, 206, 206, 205,
  205, 202, 262, 202, 268, 202, 207, 173, 252, 205,
  266, 205, 173, 205, 210, 215, 272, 272, 272, 272,
  222, 222, 222, 222, 255, 330, 258, 208, 256, 185,
  199, 257, 186, 254, 199, 215, 215, 269, 215, 212,
  199, 300, 215, 215, 215, 199, 215, 185, 215, 199,
  186, 199, 185, 202, 301, 186, 264, 267, 199, 215,
  302, 205, 202, 215, 215, 202, 266, 300, 329, 199,
  205, 199, 328, 205, 301, 268, 327, 326, 325, 324,
  323, 322, 321, 320, 302, 319, 318, 317, 316, 315,

  314, 313, 312, 311, 310, 309, 308, 307, 306, 269,
  38, 38, 38, 38, 38, 38, 38, 38, 38, 74,
  74, 74, 74, 74, 74, 74, 74, 74, 78, 78,
  78, 78, 78, 78, 78, 78, 78, 82, 82, 82,
  82, 82, 82, 82, 82, 82, 90, 90, 90, 90,
  90, 90, 90, 90, 90, 103, 103, 103, 103, 103,
  103, 103, 103, 103, 106, 106, 106, 106, 106, 106,
  106, 106, 106, 148, 148, 148, 149, 149, 149, 149,
  149, 149, 305, 149, 152, 304, 152, 152, 152, 152,
  152, 152, 152, 168, 168, 168, 168, 168, 168, 168,

  168, 168, 170, 303, 170, 217, 214, 262, 170, 184,
  184, 184, 184, 184, 184, 184, 184, 184, 194, 194,
  194, 194, 194, 194, 194, 194, 194, 213, 213, 213,
  213, 213, 213, 213, 213, 213, 216, 216, 216, 216,
  216, 216, 216, 216, 216, 219, 261, 219, 219, 219,
  219, 219, 251, 251, 251, 251, 251, 251, 251, 251,
  251, 270, 270, 270, 270, 270, 270, 270, 270, 270,
  271, 271, 271, 271, 271, 271, 271, 271, 271, 260,
  169, 299, 298, 297, 296, 295, 294, 293, 292, 291,
  290, 289, 288, 287, 286, 285, 284, 283, 282, 281,

  280, 279, 278, 277, 276, 275, 274, 273, 217, 217,
  218, 217, 214, 214, 194, 184, 179, 178, 177, 169,
  169, 150, 248, 247, 246, 245, 244, 243, 242, 241,
  240, 239, 238, 237, 236, 235, 234, 233, 228, 227,
  226, 225, 224, 223, 112, 110, 218, 217, 217, 214,
  214, 184, 169, 169, 151, 150, 145, 145, 131, 119,
  137, 131, 130, 129, 122, 115, 112, 110, 352, 39,
  39, 37, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,

  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352
};

static const short int yy_chk[954] = { 0,
  0, 1, 19, 1, 0, 19, 0, 1, 1, 1,
  1, 1, 182, 1, 1, 1, 1, 2, 20, 2,
  0, 20, 0, 2, 2, 2, 2, 2, 0, 2,
  2, 2, 2, 3, 21, 3, 0, 21, 182, 3,
  3, 3, 3, 3, 57, 3, 3, 3, 3, 4,
  22, 4, 207, 22, 57, 4, 4, 4, 4, 4,
  7, 4, 4, 4, 4, 207, 7, 7, 7, 7,
  7, 8, 7, 7, 7, 7, 349, 8, 8, 8,
  8, 8, 17, 8, 8, 8, 8, 11, 11, 23,
  347, 24, 23, 18, 24, 64, 58, 7, 11, 11,

  11, 11, 11, 11, 31, 64, 32, 31, 8, 32,
  12, 12, 33, 58, 34, 33, 17, 34, 70, 17,
  7, 12, 12, 12, 12, 12, 12, 18, 59, 70,
  18, 8, 9, 9, 35, 27, 36, 35, 342, 36,
  59, 27, 27, 9, 9, 9, 9, 9, 9, 9,
  27, 63, 9, 90, 9, 63, 90, 9, 9, 9,
  9, 9, 340, 9, 9, 9, 72, 72, 63, 27,
  9, 27, 27, 13, 13, 127, 339, 13, 43, 43,
  43, 43, 127, 9, 13, 13, 13, 13, 13, 13,
  14, 14, 183, 28, 14, 47, 47, 47, 47, 28,

  28, 14, 14, 14, 14, 14, 14, 25, 28, 26,
  126, 338, 126, 25, 25, 26, 26, 25, 183, 26,
  336, 85, 25, 85, 26, 85, 89, 28, 89, 28,
  28, 29, 30, 29, 30, 208, 13, 29, 30, 13,
  13, 29, 30, 25, 334, 26, 29, 30, 50, 50,
  50, 50, 91, 14, 89, 91, 14, 14, 15, 52,
  52, 52, 52, 53, 53, 53, 53, 29, 30, 208,
  15, 15, 15, 15, 87, 15, 15, 15, 15, 15,
  15, 55, 68, 87, 68, 68, 68, 68, 94, 68,
  68, 92, 333, 92, 332, 94, 15, 15, 15, 15,

  15, 15, 95, 86, 87, 95, 55, 86, 147, 147,
  55, 80, 86, 88, 94, 88, 175, 94, 175, 92,
  88, 81, 92, 175, 331, 80, 80, 80, 80, 80,
  180, 80, 80, 86, 80, 180, 81, 330, 80, 80,
  80, 81, 80, 80, 80, 96, 80, 80, 80, 80,
  80, 146, 81, 93, 146, 80, 80, 81, 184, 80,
  80, 184, 93, 81, 181, 80, 80, 80, 98, 181,
  328, 96, 98, 96, 96, 171, 81, 98, 327, 171,
  326, 93, 99, 93, 93, 105, 99, 100, 99, 101,
  99, 100, 172, 102, 187, 101, 172, 101, 98, 102,

  100, 102, 101, 325, 109, 105, 105, 174, 105, 174,
  253, 174, 105, 105, 105, 253, 105, 185, 105, 109,
  185, 100, 187, 194, 109, 187, 194, 102, 176, 105,
  176, 323, 188, 105, 105, 109, 111, 111, 111, 111,
  109, 113, 113, 113, 113, 191, 109, 114, 114, 114,
  114, 118, 118, 118, 118, 173, 176, 192, 193, 109,
  188, 190, 203, 188, 173, 189, 203, 189, 190, 321,
  203, 191, 320, 191, 191, 318, 192, 193, 317, 192,
  193, 196, 199, 196, 196, 173, 197, 190, 197, 197,
  190, 199, 201, 189, 201, 198, 189, 198, 200, 198,

  200, 209, 204, 205, 206, 200, 204, 205, 206, 209,
  204, 210, 199, 211, 209, 212, 205, 254, 252, 210,
  201, 211, 252, 212, 210, 214, 221, 221, 221, 221,
  222, 222, 222, 222, 255, 316, 258, 205, 256, 257,
  258, 257, 257, 254, 265, 214, 214, 211, 214, 212,
  266, 259, 214, 214, 214, 259, 214, 256, 214, 263,
  256, 264, 255, 267, 263, 255, 264, 267, 302, 214,
  265, 267, 268, 214, 214, 269, 266, 300, 315, 301,
  268, 300, 314, 269, 301, 268, 313, 312, 311, 310,
  308, 307, 306, 305, 302, 304, 290, 289, 288, 287,

  286, 285, 284, 283, 282, 281, 278, 277, 276, 269,
  353, 353, 353, 353, 353, 353, 353, 353, 353, 354,
  354, 354, 354, 354, 354, 354, 354, 354, 355, 355,
  355, 355, 355, 355, 355, 355, 355, 356, 356, 356,
  356, 356, 356, 356, 356, 356, 357, 357, 357, 357,
  357, 357, 357, 357, 357, 358, 358, 358, 358, 358,
  358, 358, 358, 358, 359, 359, 359, 359, 359, 359,
  359, 359, 359, 360, 360, 360, 361, 361, 361, 361,
  361, 361, 275, 361, 362, 274, 362, 362, 362, 362,
  362, 362, 362, 363, 363, 363, 363, 363, 363, 363,

  363, 363, 364, 273, 364, 271, 270, 262, 364, 365,
  365, 365, 365, 365, 365, 365, 365, 365, 366, 366,
  366, 366, 366, 366, 366, 366, 366, 367, 367, 367,
  367, 367, 367, 367, 367, 367, 368, 368, 368, 368,
  368, 368, 368, 368, 368, 369, 261, 369, 369, 369,
  369, 369, 370, 370, 370, 370, 370, 370, 370, 370,
  370, 371, 371, 371, 371, 371, 371, 371, 371, 371,
  372, 372, 372, 372, 372, 372, 372, 372, 372, 260,
  251, 250, 249, 248, 247, 246, 245, 244, 243, 242,
  241, 240, 239, 238, 237, 236, 235, 234, 233, 231,

  230, 229, 228, 227, 226, 225, 224, 223, 219, 218,
  217, 216, 215, 213, 195, 186, 179, 178, 177, 170,
  168, 150, 144, 143, 142, 141, 140, 139, 138, 137,
  136, 135, 134, 133, 132, 130, 129, 128, 125, 124,
  123, 122, 121, 120, 112, 110, 108, 107, 106, 104,
  103, 97, 83, 82, 77, 76, 71, 69, 67, 66,
  65, 62, 61, 60, 56, 49, 46, 41, 37, 6,
  5, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,

  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352, 352, 352, 352, 352, 352, 352, 352,
  352, 352, 352
};

static yy_state_type yy_last_accepting_state;
static YY_CHAR *yy_last_accepting_cpos;

/* the intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
/* points to current character in buffer */
static YY_CHAR *yy_c_buf_p = (YY_CHAR *) 0;
static int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

static yy_state_type yy_get_previous_state YY_PROTO ((void));
static yy_state_type yy_try_NUL_trans YY_PROTO ((yy_state_type current_state));
static int yy_get_next_buffer YY_PROTO ((void));
static void yyunput YY_PROTO ((YY_CHAR c, YY_CHAR * buf_ptr));
void yyrestart YY_PROTO ((FILE * input_file));
void yy_switch_to_buffer YY_PROTO ((YY_BUFFER_STATE new_buffer));
void yy_load_buffer_state YY_PROTO ((void));
YY_BUFFER_STATE yy_create_buffer YY_PROTO ((FILE * file, int size));
void yy_delete_buffer YY_PROTO ((YY_BUFFER_STATE b));
void yy_init_buffer YY_PROTO ((YY_BUFFER_STATE b, FILE * file));

#define yy_new_buffer yy_create_buffer

#ifdef __cplusplus
static int yyinput YY_PROTO ((void));
#else
static int input YY_PROTO ((void));
#endif

YY_DECL
{
  yy_state_type yy_current_state;
  YY_CHAR *yy_cp, *yy_bp;
  int yy_act;


  /* Preliminary "actions" */
  if (cnv_fmt__unlex && yy_current_buffer->yy_eof_status != EOF_DONE)
    {
      /*
       * Push back current token so that it can be read again.
       * See cnv_fmt_unlex().
       */
      int i;
      for (i = yyleng - 1; i >= 0; --i)
	{
	  unput (yytext[i]);
	}
      cnv_fmt__next -= yyleng;
      cnv_fmt__unlex = 0;
    }



  if (yy_init)
    {
      YY_USER_INIT;

      if (!yy_start)
	yy_start = 1;		/* first start state */

      if (!yyin)
	yyin = stdin;

      if (!yyout)
	yyout = stdout;

      if (yy_current_buffer)
	yy_init_buffer (yy_current_buffer, yyin);
      else
	yy_current_buffer = yy_create_buffer (yyin, YY_BUF_SIZE);

      yy_load_buffer_state ();

      yy_init = 0;
    }

  while (1)			/* loops until end-of-file is reached */
    {
      yy_cp = yy_c_buf_p;

      /* support of yytext */
      *yy_cp = yy_hold_char;

      /* yy_bp points to the position in yy_ch_buf of the start of the current run. */
      yy_bp = yy_cp;

      yy_current_state = yy_start;
    yy_match:
      do
	{
	  YY_CHAR yy_c = yy_ec[*yy_cp];
	  if (yy_accept[yy_current_state])
	    {
	      yy_last_accepting_state = yy_current_state;
	      yy_last_accepting_cpos = yy_cp;
	    }
	  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
	    {
	      yy_current_state = yy_def[yy_current_state];
	      if (yy_current_state >= 353)
		yy_c = yy_meta[yy_c];
	    }
	  yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	  ++yy_cp;
	}
      while (yy_current_state != 352);
      yy_cp = yy_last_accepting_cpos;
      yy_current_state = yy_last_accepting_state;

    yy_find_action:
      yy_act = yy_accept[yy_current_state];

      YY_DO_BEFORE_ACTION;
      YY_USER_ACTION;

    do_action:			/* this label is used only to access EOF actions */


      switch (yy_act)
	{
	case 0:		/* must backtrack */
	  /* undo the effects of YY_DO_BEFORE_ACTION */
	  *yy_cp = yy_hold_char;
	  yy_cp = yy_last_accepting_cpos;
	  yy_current_state = yy_last_accepting_state;
	  goto yy_find_action;

	case 1:
	  {
	    DB_FMT_LEX_RETURN (FT_MINUS);
	  }
	  YY_BREAK case 2:
	  {
	    DB_FMT_LEX_RETURN (FT_PLUS);
	  }
	  YY_BREAK case 3:
	  {
	    DB_FMT_LEX_RETURN (FT_DECIMAL);
	  }
	  YY_BREAK case 4:
	  {
	    DB_FMT_LEX_RETURN (FT_CURRENCY);
	  }
	  YY_BREAK case 5:
	  {
	    DB_FMT_LEX_RETURN (FT_CURRENCY);
	  }
	  YY_BREAK case 6:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_THOUSANDS);
	  }
	  YY_BREAK case 7:
	  {
	    /* Number with no leading or trailing zeroes. */
	    DB_FMT_LEX_RETURN (FT_NUMBER);
	  }
	  YY_BREAK case 8:
	  {
	    DB_FMT_LEX_RETURN (FT_STARS);
	  }
	  YY_BREAK case 9:
	  {
	    DB_FMT_LEX_RETURN (FT_ZEROES);
	  }
	  YY_BREAK case 10:
	  {
	    DB_FMT_LEX_RETURN (FT_TIME_DIGITS_0);
	  }
	  YY_BREAK case 11:
	  {
	    DB_FMT_LEX_RETURN (FT_TIME_DIGITS_BLANK);
	  }
	  YY_BREAK case 12:
	  {
	    DB_FMT_LEX_RETURN (FT_TIME_DIGITS);
	  }
	  YY_BREAK case 13:
	  {
	    DB_FMT_LEX_RETURN (FT_TIME_DIGITS_ANY);
	  }
	  YY_BREAK case 14:
	  {
	    DB_FMT_LEX_RETURN (FT_DATE_SEPARATOR);
	  }
	  YY_BREAK case 15:
	  {
	    DB_FMT_LEX_RETURN (FT_TIME_SEPARATOR);
	  }
	  YY_BREAK case 16:
	  {
	    DB_FMT_LEX_RETURN (FT_LOCAL_DATE_SEPARATOR);
	  }
	  YY_BREAK case 17:
	  {
	    token->value = 0;
	    DB_FMT_LEX_RETURN (FT_AM_PM);
	  }
	  YY_BREAK case 18:
	  {
	    token->value = 1;
	    DB_FMT_LEX_RETURN (FT_AM_PM);
	  }
	  YY_BREAK case 19:
	  {
	    token->value = 0;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY_LONG);
	  }
	  YY_BREAK case 20:
	  {
	    token->value = 1;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY_LONG);
	  }
	  YY_BREAK case 21:
	  {
	    token->value = 2;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY_LONG);
	  }
	  YY_BREAK case 22:
	  {
	    token->value = 3;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY_LONG);
	  }
	  YY_BREAK case 23:
	  {
	    token->value = 4;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY_LONG);
	  }
	  YY_BREAK case 24:
	  {
	    token->value = 5;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY_LONG);
	  }
	  YY_BREAK case 25:
	  {
	    token->value = 6;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY_LONG);
	  }
	  YY_BREAK case 26:
	  {
	    token->value = 0;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 27:
	  {
	    token->value = 1;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 28:
	  {
	    token->value = 2;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 29:
	  {
	    token->value = 3;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 30:
	  {
	    token->value = 4;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 31:
	  {
	    token->value = 5;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 32:
	  {
	    token->value = 6;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 33:
	  {
	    token->value = 1;
	    DB_FMT_LEX_RETURN (FT_MONTH_LONG);
	  }
	  YY_BREAK case 34:
	  {
	    token->value = 2;
	    DB_FMT_LEX_RETURN (FT_MONTH_LONG);
	  }
	  YY_BREAK case 35:
	  {
	    token->value = 3;
	    DB_FMT_LEX_RETURN (FT_MONTH_LONG);
	  }
	  YY_BREAK case 36:
	  {
	    token->value = 4;
	    DB_FMT_LEX_RETURN (FT_MONTH_LONG);
	  }
	  YY_BREAK case 37:
	  {
	    token->value = 5;
	    DB_FMT_LEX_RETURN (FT_MONTH_LONG);
	  }
	  YY_BREAK case 38:
	  {
	    token->value = 6;
	    DB_FMT_LEX_RETURN (FT_MONTH_LONG);
	  }
	  YY_BREAK case 39:
	  {
	    token->value = 7;
	    DB_FMT_LEX_RETURN (FT_MONTH_LONG);
	  }
	  YY_BREAK case 40:
	  {
	    token->value = 8;
	    DB_FMT_LEX_RETURN (FT_MONTH_LONG);
	  }
	  YY_BREAK case 41:
	  {
	    token->value = 9;
	    DB_FMT_LEX_RETURN (FT_MONTH_LONG);
	  }
	  YY_BREAK case 42:
	  {
	    token->value = 10;
	    DB_FMT_LEX_RETURN (FT_MONTH_LONG);
	  }
	  YY_BREAK case 43:
	  {
	    token->value = 11;
	    DB_FMT_LEX_RETURN (FT_MONTH_LONG);
	  }
	  YY_BREAK case 44:
	  {
	    token->value = 12;
	    DB_FMT_LEX_RETURN (FT_MONTH_LONG);
	  }
	  YY_BREAK case 45:
	  {
	    token->value = 1;
	    DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 46:
	  {
	    token->value = 2;
	    DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 47:
	  {
	    token->value = 3;
	    DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 48:
	  {
	    token->value = 4;
	    DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 49:
	  {
	    token->value = 5;
	    DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 50:
	  {
	    token->value = 6;
	    DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 51:
	  {
	    token->value = 7;
	    DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 52:
	  {
	    token->value = 8;
	    DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 53:
	  {
	    token->value = 9;
	    DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 54:
	  {
	    token->value = 10;
	    DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 55:
	  {
	    token->value = 11;
	    DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 56:
	  {
	    token->value = 12;
	    DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 57:
	  {
	    DB_FMT_LEX_RETURN (FT_NUMBER);
	  }
	  YY_BREAK case 58:
	  {
	    DB_FMT_LEX_RETURN (FT_PATTERN);
	  }
	  YY_BREAK case 59:
	  {
	    /* Escaped X is treated like a pattern char. */
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_PATTERN);
	  }
	  YY_BREAK case 60:
	  {
	    DB_FMT_LEX_RETURN (FT_PATTERN);
	  }
	  YY_BREAK case 61:
	  {
	    /* Escaped % is treated like a pattern char. */
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_PATTERN);
	  }
	  YY_BREAK case 62:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_DATE);
	  }
	  YY_BREAK case 63:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_YEAR);
	  }
	  YY_BREAK case 64:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_MONTH);
	  }
	  YY_BREAK case 65:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_MONTHDAY);
	  }
	  YY_BREAK case 66:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 67:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_HOUR);
	  }
	  YY_BREAK case 68:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_MINUTE);
	  }
	  YY_BREAK case 69:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_SECOND);
	  }
	  YY_BREAK case 70:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_AM_PM);
	  }
	  YY_BREAK case 71:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_ZONE);
	  }
	  YY_BREAK case 72:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_TIME);
	  }
	  YY_BREAK case 73:
	  {
	    int csize = mblen (token->text, token->length);
	      token->text += csize;
	      token->length -= csize;
	      DB_FMT_LEX_RETURN (FT_TIMESTAMP);
	  }
	  YY_BREAK case 74:
	  {
	    DB_FMT_LEX_RETURN (FT_DATE_FORMAT);
	  }
	  YY_BREAK case 75:
	  {
	    DB_FMT_LEX_RETURN (FT_FLOAT_FORMAT);
	  }
	  YY_BREAK case 76:
	  {
	    DB_FMT_LEX_RETURN (FT_INTEGER_FORMAT);
	  }
	  YY_BREAK case 77:
	  {
	    DB_FMT_LEX_RETURN (FT_INTEGER_FORMAT);
	  }
	  YY_BREAK case 78:
	  {
	    DB_FMT_LEX_RETURN (FT_MONETARY_FORMAT);
	  }
	  YY_BREAK case 79:
	  {
	    DB_FMT_LEX_RETURN (FT_TIME_FORMAT);
	  }
	  YY_BREAK case 80:
	  {
	    DB_FMT_LEX_RETURN (FT_TIMESTAMP_FORMAT);
	  }
	  YY_BREAK case 81:
	  {
	    DB_FMT_LEX_RETURN (FT_BIT_STRING_FORMAT);
	  }
	  YY_BREAK case 82:
	  {
	    DB_FMT_LEX_RETURN (FT_BINARY_DIGITS);
	  }
	  YY_BREAK case 83:
	  {
	    DB_FMT_LEX_RETURN (FT_HEX_DIGITS);
	  }
	  YY_BREAK case 84:
	  {
	    DB_FMT_LEX_RETURN (FT_BINARY_DIGITS);
	  }
	  YY_BREAK case 85:
	  {
	    DB_FMT_LEX_RETURN (FT_HEX_DIGITS);
	  }
	  YY_BREAK case 86:
	  {
	    token->value = 0;
	    DB_FMT_LEX_RETURN (FT_AM_PM);
	  }
	  YY_BREAK case 87:
	  {
	    token->value = 1;
	    DB_FMT_LEX_RETURN (FT_AM_PM);
	  }
	  YY_BREAK case 88:
	  {
	    token->value = 0;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 89:
	  {
	    token->value = 1;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 90:
	  {
	    token->value = 2;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 91:
	  {
	    token->value = 3;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 92:
	  {
	    token->value = 4;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 93:
	  {
	    token->value = 5;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 94:
	  {
	    token->value = 6;
	    DB_FMT_LEX_RETURN (FT_WEEKDAY);
	  }
	  YY_BREAK case 95:
	  {
	    DB_FMT_LEX_RETURN (FT_UNKNOWN);
	  }
	  YY_BREAK case YY_STATE_EOF (INITIAL):case YY_STATE_EOF (SC_US_ENG_NUMBER):case
	    YY_STATE_EOF (SC_KO_KR_NUMBER):case YY_STATE_EOF (SC_US_ENG_TIME):case YY_STATE_EOF (SC_KO_KR_TIME):case
	    YY_STATE_EOF (SC_BIT_STRING):case YY_STATE_EOF (SC_INTEGER_FORMAT):case YY_STATE_EOF (SC_TIME_FORMAT):case
	    YY_STATE_EOF (SC_BIT_STRING_FORMAT):case YY_STATE_EOF (SC_VALIDATE_DATE_FORMAT):case
	    YY_STATE_EOF (SC_VALIDATE_FLOAT_FORMAT):case YY_STATE_EOF (SC_VALIDATE_INTEGER_FORMAT):case
	    YY_STATE_EOF (SC_VALIDATE_MONETARY_FORMAT):case YY_STATE_EOF (SC_VALIDATE_TIME_FORMAT):case
	    YY_STATE_EOF (SC_VALIDATE_TIMESTAMP_FORMAT):case YY_STATE_EOF (SC_VALIDATE_BIT_STRING_FORMAT):
	  {
	    cnv_fmt__next = cnv_fmt__input;
	    token->type = FT_NONE;
	    token->text = token->raw_text = cnv_fmt__input;
	    token->length = 0;
	    yyterminate ();
	  }
	  YY_BREAK case 97:ECHO;
	  YY_BREAK case YY_END_OF_BUFFER:
	  {
	    /* amount of text matched not including the EOB char */
	    int yy_amount_of_matched_text = (int) (yy_cp - yytext - 1);

	    /* undo the effects of YY_DO_BEFORE_ACTION */
	     *yy_cp = yy_hold_char;

	    /* note that here we test for yy_c_buf_p "<=" to the position of the first EOB in the buffer, since
	     * yy_c_buf_p will already have been incremented past the NUL character (since all states make transitions
	     * on EOB to the end- of-buffer state).  Contrast this with the test in yyinput(). */
	    if (yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars])
	      /* this was really a NUL */
	      {
		yy_state_type yy_next_state;

		  yy_c_buf_p = yytext + yy_amount_of_matched_text;

		  yy_current_state = yy_get_previous_state ();

		/* okay, we're now positioned to make the NUL transition.  We couldn't have yy_get_previous_state() go
		 * ahead and do it for us because it doesn't know how to deal with the possibility of jamming (and we
		 * don't want to build jamming into it because then it will run more slowly) */

		  yy_next_state = yy_try_NUL_trans (yy_current_state);

		  yy_bp = yytext + YY_MORE_ADJ;

		if (yy_next_state)
		  {
		    /* consume the NUL */
		    yy_cp = ++yy_c_buf_p;
		    yy_current_state = yy_next_state;
		    goto yy_match;
		  }

		else
		  {
		    yy_cp = yy_last_accepting_cpos;
		    yy_current_state = yy_last_accepting_state;
		    goto yy_find_action;
		  }
	      }

	    else
	      switch (yy_get_next_buffer ())
		{
		case EOB_ACT_END_OF_FILE:
		  {
		    yy_did_buffer_switch_on_eof = 0;

		    if (yywrap ())
		      {
			/* note: because we've taken care in yy_get_next_buffer() to have set up yytext, we can now set
			 * up yy_c_buf_p so that if some total hoser (like flex itself) wants to call the scanner after
			 * we return the YY_NULL, it'll still work - another YY_NULL will get returned. */
			yy_c_buf_p = yytext + YY_MORE_ADJ;

			yy_act = YY_STATE_EOF ((yy_start - 1) / 2);
			goto do_action;
		      }

		    else
		      {
			if (!yy_did_buffer_switch_on_eof)
			  YY_NEW_FILE;
		      }
		  }
		  break;

		case EOB_ACT_CONTINUE_SCAN:
		  yy_c_buf_p = yytext + yy_amount_of_matched_text;

		  yy_current_state = yy_get_previous_state ();

		  yy_cp = yy_c_buf_p;
		  yy_bp = yytext + YY_MORE_ADJ;
		  goto yy_match;

		case EOB_ACT_LAST_MATCH:
		  yy_c_buf_p = &yy_current_buffer->yy_ch_buf[yy_n_chars];

		  yy_current_state = yy_get_previous_state ();

		  yy_cp = yy_c_buf_p;
		  yy_bp = yytext + YY_MORE_ADJ;
		  goto yy_find_action;
		}
	    break;
	  }

	default:
#ifdef FLEX_DEBUG
	  printf ("action # %d\n", yy_act);
#endif
	  YY_FATAL_ERROR ("fatal flex scanner internal error--no action found");
	}
    }
}


/* yy_get_next_buffer - try to read in a new buffer
 *
 * synopsis
 *     int yy_get_next_buffer();
 *
 * returns a code representing an action
 *     EOB_ACT_LAST_MATCH -
 *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *     EOB_ACT_END_OF_FILE - end of file
 */

static int
yy_get_next_buffer ()
{
  YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
  YY_CHAR *source = yytext - 1;	/* copy prev. char, too */
  int number_to_move, i;
  int ret_val;

  if (yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1])
    YY_FATAL_ERROR ("fatal flex scanner internal error--end of buffer missed");

  /* try to read more data */

  /* first move last chars to start of buffer */
  number_to_move = (int) (yy_c_buf_p - yytext);

  for (i = 0; i < number_to_move; ++i)
    *(dest++) = *(source++);

  if (yy_current_buffer->yy_eof_status != EOF_NOT_SEEN)
    /* don't do the read, it's not guaranteed to return an EOF, just force an EOF */
    yy_n_chars = 0;

  else
    {
      int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;

      if (num_to_read > YY_READ_BUF_SIZE)
	num_to_read = YY_READ_BUF_SIZE;

      else if (num_to_read <= 0)
	YY_FATAL_ERROR ("fatal error - scanner input buffer overflow");

      /* read in more data */
      YY_INPUT ((&yy_current_buffer->yy_ch_buf[number_to_move]), yy_n_chars, num_to_read);
    }

  if (yy_n_chars == 0)
    {
      if (number_to_move == 1)
	{
	  ret_val = EOB_ACT_END_OF_FILE;
	  yy_current_buffer->yy_eof_status = EOF_DONE;
	}

      else
	{
	  ret_val = EOB_ACT_LAST_MATCH;
	  yy_current_buffer->yy_eof_status = EOF_PENDING;
	}
    }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  yy_n_chars += number_to_move;
  yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
  yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

  /* yytext begins at the second character in yy_ch_buf; the first character is the one which preceded it before
   * reading in the latest buffer; it needs to be kept around in case it's a newline, so yy_get_previous_state() will
   * have with '^' rules active */

  yytext = &yy_current_buffer->yy_ch_buf[1];

  return (ret_val);
}


/* yy_get_previous_state - get the state just before the EOB char was reached
 *
 * synopsis
 *     yy_state_type yy_get_previous_state();
 */

static yy_state_type
yy_get_previous_state ()
{
  yy_state_type yy_current_state;
  YY_CHAR *yy_cp;

  yy_current_state = yy_start;

  for (yy_cp = yytext + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp)
    {
      YY_CHAR yy_c = (*yy_cp ? yy_ec[*yy_cp] : 1);
      if (yy_accept[yy_current_state])
	{
	  yy_last_accepting_state = yy_current_state;
	  yy_last_accepting_cpos = yy_cp;
	}
      while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
	{
	  yy_current_state = yy_def[yy_current_state];
	  if (yy_current_state >= 353)
	    yy_c = yy_meta[yy_c];
	}
      yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    }

  return (yy_current_state);
}


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *     next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type
yy_try_NUL_trans (yy_state_type yy_current_state)
#else
static yy_state_type
yy_try_NUL_trans (yy_current_state)
     register yy_state_type yy_current_state;
#endif

{
  int yy_is_jam;
  YY_CHAR *yy_cp = yy_c_buf_p;

  YY_CHAR yy_c = 1;
  if (yy_accept[yy_current_state])
    {
      yy_last_accepting_state = yy_current_state;
      yy_last_accepting_cpos = yy_cp;
    }
  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
    {
      yy_current_state = yy_def[yy_current_state];
      if (yy_current_state >= 353)
	yy_c = yy_meta[yy_c];
    }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  yy_is_jam = (yy_current_state == 352);

  return (yy_is_jam ? 0 : yy_current_state);
}


#ifdef YY_USE_PROTOS
static void
yyunput (YY_CHAR c, YY_CHAR * yy_bp)
#else
static void
yyunput (c, yy_bp)
     YY_CHAR c;
     register YY_CHAR *yy_bp;
#endif

{
  YY_CHAR *yy_cp = yy_c_buf_p;

  /* undo effects of setting up yytext */
  *yy_cp = yy_hold_char;

  if (yy_cp < yy_current_buffer->yy_ch_buf + 2)
    {				/* need to shift things up to make room */
      int number_to_move = yy_n_chars + 2;	/* +2 for EOB chars */
      YY_CHAR *dest = &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
      YY_CHAR *source = &yy_current_buffer->yy_ch_buf[number_to_move];

      while (source > yy_current_buffer->yy_ch_buf)
	*--dest = *--source;

      yy_cp += dest - source;
      yy_bp += dest - source;
      yy_n_chars = yy_current_buffer->yy_buf_size;

      if (yy_cp < yy_current_buffer->yy_ch_buf + 2)
	YY_FATAL_ERROR ("flex scanner push-back overflow");
    }

  if (yy_cp > yy_bp && yy_cp[-1] == '\n')
    yy_cp[-2] = '\n';

  *--yy_cp = c;

  /* note: the formal parameter *must* be called "yy_bp" for this macro to now work correctly */
  YY_DO_BEFORE_ACTION;		/* set up yytext again */
}


#ifdef __cplusplus
static int
yyinput ()
#else
static int
input ()
#endif
{
  int c;
  YY_CHAR *yy_cp = yy_c_buf_p;

  *yy_cp = yy_hold_char;

  if (*yy_c_buf_p == YY_END_OF_BUFFER_CHAR)
    {
      /* yy_c_buf_p now points to the character we want to return. If this occurs *before* the EOB characters, then
       * it's a valid NUL; if not, then we've hit the end of the buffer. */
      if (yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars])
	/* this was really a NUL */
	*yy_c_buf_p = '\0';

      else
	{			/* need more input */
	  yytext = yy_c_buf_p;
	  ++yy_c_buf_p;

	  switch (yy_get_next_buffer ())
	    {
	    case EOB_ACT_END_OF_FILE:
	      {
		if (yywrap ())
		  {
		    yy_c_buf_p = yytext + YY_MORE_ADJ;
		    return (EOF);
		  }

		YY_NEW_FILE;

#ifdef __cplusplus
		return (yyinput ());
#else
		return (input ());
#endif
	      }
	      break;

	    case EOB_ACT_CONTINUE_SCAN:
	      yy_c_buf_p = yytext + YY_MORE_ADJ;
	      break;

	    case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
	      YY_FATAL_ERROR ("unexpected last match in yyinput()");
#else
	      YY_FATAL_ERROR ("unexpected last match in input()");
#endif
	    }
	}
    }

  c = *yy_c_buf_p;
  yy_hold_char = *++yy_c_buf_p;

  return (c);
}


#ifdef YY_USE_PROTOS
void
yyrestart (FILE * input_file)
#else
void
yyrestart (input_file)
     FILE *input_file;
#endif

{
  yy_init_buffer (yy_current_buffer, input_file);
  yy_load_buffer_state ();
}


#ifdef YY_USE_PROTOS
void
yy_switch_to_buffer (YY_BUFFER_STATE new_buffer)
#else
void
yy_switch_to_buffer (new_buffer)
     YY_BUFFER_STATE new_buffer;
#endif

{
  if (yy_current_buffer == new_buffer)
    return;

  if (yy_current_buffer)
    {
      /* flush out information for old buffer */
      *yy_c_buf_p = yy_hold_char;
      yy_current_buffer->yy_buf_pos = yy_c_buf_p;
      yy_current_buffer->yy_n_chars = yy_n_chars;
    }

  yy_current_buffer = new_buffer;
  yy_load_buffer_state ();

  /* we don't actually know whether we did this switch during EOF (yywrap()) processing, but the only time this flag is
   * looked at is after yywrap() is called, so it's safe to go ahead and always set it. */
  yy_did_buffer_switch_on_eof = 1;
}


#ifdef YY_USE_PROTOS
void
yy_load_buffer_state (void)
#else
void
yy_load_buffer_state ()
#endif
{
  yy_n_chars = yy_current_buffer->yy_n_chars;
  yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
  yyin = yy_current_buffer->yy_input_file;
  yy_hold_char = *yy_c_buf_p;
}


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE
yy_create_buffer (FILE * file, int size)
#else
YY_BUFFER_STATE
yy_create_buffer (file, size)
     FILE *file;
     int size;
#endif

{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE) malloc (sizeof (struct yy_buffer_state));

  if (!b)
    YY_FATAL_ERROR ("out of dynamic memory in yy_create_buffer()");

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because we need to put in 2 end-of-buffer characters. */
  b->yy_ch_buf = (YY_CHAR *) malloc ((unsigned) (b->yy_buf_size + 2));

  if (!b->yy_ch_buf)
    YY_FATAL_ERROR ("out of dynamic memory in yy_create_buffer()");

  yy_init_buffer (b, file);

  return (b);
}


#ifdef YY_USE_PROTOS
void
yy_delete_buffer (YY_BUFFER_STATE b)
#else
void
yy_delete_buffer (b)
     YY_BUFFER_STATE b;
#endif

{
  if (b == yy_current_buffer)
    yy_current_buffer = (YY_BUFFER_STATE) 0;

  free ((char *) b->yy_ch_buf);
  free ((char *) b);
}


#ifdef YY_USE_PROTOS
void
yy_init_buffer (YY_BUFFER_STATE b, FILE * file)
#else
void
yy_init_buffer (b, file)
     YY_BUFFER_STATE b;
     FILE *file;
#endif

{
  b->yy_input_file = file;

  /* we put in the '\n' and start reading from [1] so that an initial match-at-newline will be true. */

  b->yy_ch_buf[0] = '\n';
  b->yy_n_chars = 1;

  /* we always need two end-of-buffer characters.  The first causes a transition to the end-of-buffer state.  The
   * second causes a jam in that state. */
  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_pos = &b->yy_ch_buf[1];

  b->yy_eof_status = EOF_NOT_SEEN;
}

/*
 * cnv_fmt_analyze() - Initialize lexical scan of instring, using
 *    the given scan mode.
 * return:
 * instring(in) :
 * mode(in) :
 */
void
cnv_fmt_analyze (const char *instring, FMT_LEX_MODE mode)
{
  assert (instring);
  cnv_fmt__input = cnv_fmt__next = instring;
  yy_init = 1;
  cnv_fmt__unlex = 0;
  cnv_fmt__mode = mode;
}

/*
 * cnv_fmt_unlex() - Push back the current token so that it can be read again.
 * return:
 */
void
cnv_fmt_unlex ()
{
  cnv_fmt__unlex = 1;		/* see rules section */
}

/*
 * cnv_fmt_next_token() - Return pointer to next lexical token in value string.
 * return:
 */
const char *
cnv_fmt_next_token ()
{
  return cnv_fmt__next;
}

/*
 * cnv_fmt_lex_start() - Return the start condition for the given scan mode.
 * return:
 * mode(in) :
 */
static int
cnv_fmt_lex_start (FMT_LEX_MODE mode)
{
  return mode == FL_LOCAL_NUMBER ? cnv_fmt_lex_start (cnv_fmt_number_mode (intl_zone (LC_MONETARY))) : mode ==
    FL_LOCAL_TIME ? cnv_fmt_lex_start (cnv_fmt_time_mode (intl_zone (LC_TIME))) : mode ==
    FL_US_ENG_NUMBER ? SC_US_ENG_NUMBER : mode == FL_KO_KR_NUMBER ? SC_KO_KR_NUMBER : mode ==
    FL_US_ENG_TIME ? SC_US_ENG_TIME : mode == FL_KO_KR_TIME ? SC_KO_KR_TIME : mode ==
    FL_INTEGER_FORMAT ? SC_INTEGER_FORMAT : mode == FL_TIME_FORMAT ? SC_TIME_FORMAT : mode ==
    FL_BIT_STRING_FORMAT ? SC_BIT_STRING_FORMAT : mode == FL_BIT_STRING ? SC_BIT_STRING : mode ==
    FL_VALIDATE_DATE_FORMAT ? SC_VALIDATE_DATE_FORMAT : mode ==
    FL_VALIDATE_FLOAT_FORMAT ? SC_VALIDATE_FLOAT_FORMAT : mode ==
    FL_VALIDATE_INTEGER_FORMAT ? SC_VALIDATE_INTEGER_FORMAT : mode ==
    FL_VALIDATE_MONETARY_FORMAT ? SC_VALIDATE_MONETARY_FORMAT : mode ==
    FL_VALIDATE_TIME_FORMAT ? SC_VALIDATE_TIME_FORMAT : mode ==
    FL_VALIDATE_TIMESTAMP_FORMAT ? SC_VALIDATE_TIMESTAMP_FORMAT : mode ==
    FL_VALIDATE_BIT_STRING_FORMAT ? SC_VALIDATE_BIT_STRING_FORMAT : INITIAL;
}


/*
 * cnv_fmt_number_mode() - Return the number value scan mode for the given zone.
 * return:
 * zone(in) :
 */
FMT_LEX_MODE
cnv_fmt_number_mode (INTL_ZONE zone)
{
  FMT_LEX_MODE mode;

  switch (zone)
    {
    case INTL_ZONE_US:
      {
	mode = FL_US_ENG_NUMBER;
	break;
      }
    case INTL_ZONE_KR:
      {
	mode = FL_KO_KR_NUMBER;
	break;
      }
    default:
      {
	assert (!"Zone not implemented!");
	mode = FL_US_ENG_NUMBER;
	break;
      }
    }

  return mode;
}


/*
 * cnv_fmt_time_mode() - Return the time value scan mode for the given zone.
 * return:
 * zone(in) :
 */
FMT_LEX_MODE
cnv_fmt_time_mode (INTL_ZONE zone)
{
  FMT_LEX_MODE mode;

  switch (zone)
    {
    case INTL_ZONE_US:
      {
	mode = FL_US_ENG_TIME;
	break;
      }
    case INTL_ZONE_KR:
      {
	mode = FL_KO_KR_TIME;
	break;
      }

    default:
      {
	assert (!"Zone not implemented!");
	mode = FL_US_ENG_TIME;
	break;
      }
    }

  return mode;
}

/*
 * cnv_fmt_exit() - Free buffers when exit.
 * return:
 */
void
cnv_fmt_exit (void)
{
  if (YY_CURRENT_BUFFER != NULL)
    {
      yy_delete_buffer (YY_CURRENT_BUFFER);
      YY_CURRENT_BUFFER = NULL;
    }
}
