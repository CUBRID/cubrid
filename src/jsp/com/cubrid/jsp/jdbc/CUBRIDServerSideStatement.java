/*
 * Copyright (C) 2008 Search Solution Corporation.
 * Copyright (c) 2016 CUBRID Corporation.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * - Neither the name of the <ORGANIZATION> nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 */

package com.cubrid.jsp.jdbc;

import com.cubrid.jsp.impl.SUStatement;
import cubrid.jdbc.driver.CUBRIDJDBCErrorCode;
import cubrid.jdbc.jci.CUBRIDCommandType;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.LinkedList;

public class CUBRIDServerSideStatement implements Statement {

    protected CUBRIDServerSideConnection connection = null;

    protected int type; // ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE,
                        // ResultSet.TYPE_SCROLL_SENSITIVE
    protected int concurrency; // ResultSet.CONCUR_READ_ONLY, ResultSet.CONCUR_UPDATABLE
    protected int holdable; // ResultSet.HOLD_CURSORS_OVER_COMMIT, ResultSet.CLOSE_CURSORS_AT_COMMIT

    protected int autoGeneratedKeys; // Statement.NO_GENERATED_KEYS, Statement.RETURN_GENERATED_KEYS
    protected int fetchSize;
    protected int fetchDirection;
    protected boolean closed;
    protected int maxRows;
    protected int maxFieldSize;
    protected int queryTimeout;

    protected LinkedList<String> batchStrings;
    protected CUBRIDServerSideResultSet currentResultSet;
    protected CUBRIDServerSideResultSet autoGeneratedKeysResultSet;

    protected SUStatement statementHandler;
    protected SUStatement autoGeneratedKeysHandler;

    protected int updateCount; // for getUpdateCount (), # of afftected by a query

    protected CUBRIDServerSideStatement(CUBRIDServerSideConnection con, int type, int concurrency, int holdable) {
        this.connection = con;
        this.type = type;
        this.concurrency = concurrency;
        this.holdable = holdable;

        fetchSize = 0;
        fetchDirection = ResultSet.FETCH_FORWARD;
        maxRows = 0;
        maxFieldSize = 0;
        queryTimeout = 0;
        updateCount = -1;

        closed = false;
        currentResultSet = null;

        autoGeneratedKeys = Statement.NO_GENERATED_KEYS;
        autoGeneratedKeysResultSet = null;

        this.batchStrings = new LinkedList<String>();
    }

    public SUStatement getStatementHandler() {
        return statementHandler;
    }

    protected void prepareInternal(String sql) throws SQLException, IOException {
        byte prepareFlag = (byte) 0;
        if (isUpdatable() || isSensitive()) {
            prepareFlag |= CUBRIDServerSideConstants.PREPARE_UPDATABLE;
        }

        /*
         * NOTE: unsupported query_info and holdable cursor in server-side JDBC if
         * (false) { // query info prepareFlag |=
         * CUBRIDServerSideConstants.PREPARE_QUERY_INFO; } if (false) { // is_holdable
         * prepareFlag |= CUBRIDServerSideConstants.PREPARE_HOLDABLE; }
         */

        statementHandler = connection.getSUConnection().prepare(sql, prepareFlag, false);
    }

    protected void executeInternal(boolean executeAll) throws IOException {
        statementHandler.execute(maxRows, maxFieldSize, executeAll, isSensitive(), isScrollable());
    }

    protected void completeResultSet() throws SQLException {
        if (currentResultSet != null) {
            currentResultSet.close();
            currentResultSet = null;
        }
    }

    protected boolean makeAutoGeneratedKeysResultSet() throws SQLException {
        // TODO: not implemented yet
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    protected void resetGeneratedKeysResultSet() {
        // TODO: not implemented yet
        /* do nothing */
    }

    private void checkIsScrollable() throws SQLException {
        // TODO: scrollable is not implemented yet
        throw new SQLException(new UnsupportedOperationException());
    }

    // ==============================================================
    // The following is JDBC Interface Implementations
    // ==============================================================

    @Override
    public void close() throws SQLException {
        if (isClosed() == false) {
            closed = true;
            completeResultSet();
            connection = null; // detach with connection
        }
    }

    @Override
    public int getMaxFieldSize() throws SQLException {
        return maxFieldSize;
    }

    @Override
    public void setMaxFieldSize(int max) throws SQLException {
        if (max < 0) {
            throw new IllegalArgumentException();
        }
        maxFieldSize = max;
    }

    @Override
    public int getMaxRows() throws SQLException {
        return maxRows;
    }

    @Override
    public void setMaxRows(int max) throws SQLException {
        if (max < 0) {
            throw new IllegalArgumentException();
        }
        maxRows = max;
    }

    @Override
    public void setEscapeProcessing(boolean enable) throws SQLException {
        /* do nothing */
    }

    @Override
    public int getQueryTimeout() throws SQLException {
        return queryTimeout;
    }

    @Override
    public void setQueryTimeout(int seconds) throws SQLException {
        final int MAX_QUERY_TIMEOUT = 2000000; // compatbile with client side
        if (seconds < 0 || seconds > MAX_QUERY_TIMEOUT) {
            throw new IllegalArgumentException();
        }

        queryTimeout = seconds;
    }

    @Override
    public void cancel() throws SQLException {
        // NOTE: I'm not sure that this has to be supported
        /* do nothing */
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        /* do nothing */
        return null;
    }

    @Override
    public void clearWarnings() throws SQLException {
        /* do nothing */
    }

    @Override
    public void setCursorName(String name) throws SQLException {
        /* do nothing */
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        return currentResultSet;
    }

    @Override
    public int getUpdateCount() throws SQLException {
        return updateCount;
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        // 0) increment ResultSet index
        statementHandler.incrementResultIndex();

        // 1) complete
        completeResultSet();

        // 2) check is result index
        if (statementHandler.getResultIndex() == statementHandler.getResultSize()) {
            updateCount = -1;
            return false;
        }

        // 3) get next index
        if (statementHandler.getResultIndex() != 0) {
            statementHandler.nextResult();
        }

        // 4) create ResultSet
        boolean isResultType = statementHandler.getCurrentResultInfo().isReusltSet();
        if (isResultType) {
            int resultSetType = this.type;
            int resultSetConcurrency = this.concurrency;
            if (isSensitive() && statementHandler.isOIDIncluded() == false) {
                resultSetType = ResultSet.TYPE_SCROLL_INSENSITIVE;
            }
            if (isUpdatable() && statementHandler.isOIDIncluded() == false) {
                resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
            }
            currentResultSet = new CUBRIDServerSideResultSet(this.connection, this, resultSetType,
                    resultSetConcurrency);
            updateCount = -1;
        } else {
            updateCount = statementHandler.getCurrentResultInfo().getResultCount();
        }

        return isResultType;
    }

    protected boolean isSensitive() {
        return (type == ResultSet.TYPE_SCROLL_SENSITIVE);
    }

    protected boolean isUpdatable() throws SQLException {
        return (getResultSetConcurrency() == ResultSet.CONCUR_UPDATABLE);
    }

    protected boolean isScrollable() {
        return (type != ResultSet.TYPE_FORWARD_ONLY);
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {
        checkIsScrollable();
        switch (direction) {
            case ResultSet.FETCH_FORWARD:
            case ResultSet.FETCH_REVERSE:
            case ResultSet.FETCH_UNKNOWN:
                fetchDirection = direction;
                break;
            default:
                throw new IllegalArgumentException();
        }
    }

    @Override
    public int getFetchDirection() throws SQLException {
        return fetchDirection;
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {
        if (rows < 0) {
            throw new IllegalArgumentException();
        }
        fetchSize = rows;
    }

    @Override
    public int getFetchSize() throws SQLException {
        return fetchSize;
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        return concurrency;
    }

    @Override
    public int getResultSetType() throws SQLException {
        return type;
    }

    @Override
    public void addBatch(String sql) throws SQLException {
        // TODO: not implemented yet
        // batchStrings.add (sql);
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    @Override
    public void clearBatch() throws SQLException {
        // TODO: not implemented yet
        // batchStrings.clear();
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    @Override
    public Connection getConnection() throws SQLException {
        return connection;
    }

    @Override
    public boolean getMoreResults(int current) throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        // TODO: not implemented yet
        throw new SQLException(new java.lang.UnsupportedOperationException());
        /*
         * if (autoGeneratedKeysResultSet == null) { // autoGeneratedKeysResultSet = new
         * CUBRIDServerSideResultSet(null); } return autoGeneratedKeysResultSet;
         */
    }

    @Override
    public int[] executeBatch() throws SQLException {
        // TODO: not implemented yet
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        try {
            // 1) complete previous resultSet
            completeResultSet();

            // 2) prepare
            prepareInternal(sql);

            // 3) check SQL Type (SELECT, CALL, GET_STATS, EVALUATE)
            if (statementHandler.getSQLType() == false) {
                // statementHandler.close()?
                statementHandler = null;
                throw CUBRIDServerSideJDBCErrorManager.createCUBRIDException(
                        CUBRIDServerSideJDBCErrorCode.ER_INVALID_QUERY_TYPE_FOR_EXECUTEQUERY, null);
            }

            // 4) execute
            executeInternal(false);

            // 5) make resultSet
            getMoreResults();

            if (this.autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS
                    && statementHandler.getStatementType() == CUBRIDCommandType.CUBRID_STMT_INSERT) {
                statementHandler.setAutoGeneratedKeys(true);
            }

        } catch (IOException e) {
            throw CUBRIDServerSideJDBCErrorManager.createCUBRIDException(CUBRIDServerSideJDBCErrorCode.ER_COMMUNICATION,
                    e);
        }

        return currentResultSet;
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        return executeUpdate(sql, Statement.NO_GENERATED_KEYS);
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        try {
            // 1) complete previous resultSet
            completeResultSet();

            // 2) prepare
            prepareInternal(sql);

            // 3) check SQL Type (SELECT, CALL, GET_STATS, EVALUATE)
            if (statementHandler.getSQLType() == true) {
                // statementHandler.close();?
                statementHandler = null;
                throw CUBRIDServerSideJDBCErrorManager.createCUBRIDException(
                        CUBRIDServerSideJDBCErrorCode.ER_INVALID_QUERY_TYPE_FOR_EXECUTEUPDATE, null);
            }

            // 4) set autoGeneratedKeys
            this.autoGeneratedKeys = autoGeneratedKeys;
            if (this.autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS
                    && statementHandler.getStatementType() == CUBRIDCommandType.CUBRID_STMT_INSERT) {
                statementHandler.setAutoGeneratedKeys(true);
            }

            // 5) execute
            executeInternal(true);

            // 6) make auto generated keys resultset
            if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS
                    && statementHandler.getStatementType() == CUBRIDCommandType.CUBRID_STMT_INSERT) {
                makeAutoGeneratedKeysResultSet();
            } else {
                resetGeneratedKeysResultSet();
            }

            // 7) make make resultSet
            getMoreResults();
            return updateCount;
        } catch (IOException e) {
            e.printStackTrace();
        }

        return 0;
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return executeUpdate(sql, Statement.NO_GENERATED_KEYS);
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return executeUpdate(sql, Statement.NO_GENERATED_KEYS);
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        return execute(sql, Statement.NO_GENERATED_KEYS);
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        try {
            // 1) complete previous resultSet
            completeResultSet();

            // 2) prepare
            prepareInternal(sql);

            // 3) set autoGeneratedKeys
            this.autoGeneratedKeys = autoGeneratedKeys;
            if (this.autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS
                    && statementHandler.getStatementType() == CUBRIDCommandType.CUBRID_STMT_INSERT) {
                statementHandler.setAutoGeneratedKeys(true);
            }

            // 4) execute
            executeInternal(true);

            // 5) make auto generated keys resultset
            if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS
                    && statementHandler.getStatementType() == CUBRIDCommandType.CUBRID_STMT_INSERT) {
                makeAutoGeneratedKeysResultSet();
            } else {
                resetGeneratedKeysResultSet();
            }

            // 6) make resultSet
            return getMoreResults();
        } catch (IOException e) {
            e.printStackTrace();
        }

        // 4) get results

        return true;
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return execute(sql, Statement.NO_GENERATED_KEYS);
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return execute(sql, Statement.NO_GENERATED_KEYS);
    }

    @Override
    public int getResultSetHoldability() throws SQLException {
        return holdable;
    }

    /* JDK 1.6 */
    @Override
    public boolean isClosed() throws SQLException {
        return closed;
    }

    /* JDK 1.6 */
    @Override
    public boolean isPoolable() throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.6 */
    @Override
    public void setPoolable(boolean poolable) throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.6 */
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.6 */
    public <T> T unwrap(Class<T> iface) throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.7 */
    @Override
    public void closeOnCompletion() throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.7 */
    @Override
    public boolean isCloseOnCompletion() throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }
}
