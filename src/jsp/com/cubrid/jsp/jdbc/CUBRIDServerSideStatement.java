/*
 * Copyright (C) 2008 Search Solution Corporation.
 * Copyright (c) 2016 CUBRID Corporation.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * - Neither the name of the <ORGANIZATION> nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 */

package com.cubrid.jsp.jdbc;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.LinkedList;

import cubrid.jdbc.driver.CUBRIDJDBCErrorCode;
import cubrid.jdbc.driver.CUBRIDException;

public class CUBRIDServerSideStatement implements Statement {

    protected CUBRIDServerSideConnection connection = null;
    
    protected int type; // ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.TYPE_SCROLL_SENSITIVE
    protected int concurrency; // ResultSet.CONCUR_READ_ONLY, ResultSet.CONCUR_UPDATABLE
    protected int holdable; // ResultSet.HOLD_CURSORS_OVER_COMMIT, ResultSet.CLOSE_CURSORS_AT_COMMIT

    protected int autoGeneratedKeys; // Statement.NO_GENERATED_KEYS, Statement.RETURN_GENERATED_KEYS
    protected int fetchSize;
    protected int fetchDirection;
    protected boolean closed;
    protected int maxRows;
    protected int maxFieldSize;
    protected int queryTimeout;
    protected int updateCount; // for getUpdateCount ()

    protected LinkedList<String> batchStrings;
    protected CUBRIDServerSideResultSet currentResultSet;
    protected CUBRIDServerSideResultSet autoGeneratedKeysResultSet;

    protected CUBRIDServerSideStatement(CUBRIDServerSideConnection con, int type, int concurrency, int holdable) {
        this.connection = con;
        this.type = type;
        this.concurrency = concurrency;
        this.holdable = holdable;

        fetchSize = 0;
        fetchDirection = ResultSet.FETCH_FORWARD;

        maxRows = 0;
        maxFieldSize = 0;

        queryTimeout = 0;

        updateCount = -1;

        closed = false;
        currentResultSet = null;

        autoGeneratedKeys = Statement.NO_GENERATED_KEYS;
        autoGeneratedKeysResultSet = null;

        this.batchStrings = new LinkedList<String>();
    }

    protected void prepareInternal (String sql) throws SQLException {
        // TODO
        byte prepareFlag = (byte) 0;
        if (isUpdatable() || isSensitive()) {
            // PREPARE_UPDATABLE
        }
        if (false) { // TODO: query info 
            // PREPARE QUERY INFO
        }
        if (false) {
            // PREPARE HOLDABLE
        }

        connection.requestPrepare (sql, prepareFlag);
    }

    protected void executeInternal () {
        // TODO


    }

    protected void completeResultSet () throws SQLException {
        if (currentResultSet != null) {
            currentResultSet.close ();
            currentResultSet = null;
        }
    }

    // ==============================================================
    // The following is JDBC Interface Implementations
    // ==============================================================

    public void close() throws SQLException {
        if (isClosed () == false) {
            closed = true;
            completeResultSet ();
            connection.removeStatement (this); // remove this statement
            connection = null; // detach with connection
        }
    }

    public int getMaxFieldSize() throws SQLException {
        return maxFieldSize;
    }

    public void setMaxFieldSize(int max) throws SQLException {
        if (max < 0) {
            throw new IllegalArgumentException();
        }
        maxFieldSize = max;
    }

    public int getMaxRows() throws SQLException {
        return maxRows;
    }

    public void setMaxRows(int max) throws SQLException {
        if (max < 0) {
            throw new IllegalArgumentException();
        }
        maxRows = max;
    }

    public void setEscapeProcessing(boolean enable) throws SQLException {
        /* do nothing */
    }

    public int getQueryTimeout() throws SQLException {
        return queryTimeout;
    }

    public void setQueryTimeout(int seconds) throws SQLException {
        final int MAX_QUERY_TIMEOUT = 2000000; // compatbile with client side
        if (seconds < 0 || seconds > MAX_QUERY_TIMEOUT) {
            throw new IllegalArgumentException();
        }

        queryTimeout = seconds;
    }

    public void cancel() throws SQLException {
        // TODO: I'm not sure that this has to be supported
    }

    public SQLWarning getWarnings() throws SQLException {
        /* do nothing */
        return null;
    }

    public void clearWarnings() throws SQLException {
        /* do nothing */
    }

    public void setCursorName(String name) throws SQLException {
        /* do nothing */
    }

    public ResultSet getResultSet() throws SQLException {
        return currentResultSet;
    }

    public int getUpdateCount() throws SQLException {
        return updateCount;
    }

    public boolean getMoreResults() throws SQLException {
        completeResultSet ();
        
        // TODO
        return true;
    }

    protected boolean isSensitive ()
    {
        return (type == ResultSet.TYPE_SCROLL_SENSITIVE);
    }

    protected boolean isUpdatable () throws SQLException
    {
        return (getResultSetConcurrency() == ResultSet.CONCUR_UPDATABLE);
    }

    protected boolean isScrollable ()
    {
        return (type != ResultSet.TYPE_FORWARD_ONLY);
    }

    public void setFetchDirection(int direction) throws SQLException {
        if (!isScrollable()) {
            CUBRIDServerSideJDBCErrorManager.createCUBRIDException (CUBRIDJDBCErrorCode.non_scrollable_statement, null);
            return;
        }

        switch (direction) {
            case ResultSet.FETCH_FORWARD:
            case ResultSet.FETCH_REVERSE:
            case ResultSet.FETCH_UNKNOWN:
                fetchDirection = direction;
                break;
            default:
                throw new IllegalArgumentException();
        }
    }

    public int getFetchDirection() throws SQLException {
        return fetchDirection;
    }

    public void setFetchSize(int rows) throws SQLException {
        if (rows < 0) {
            throw new IllegalArgumentException();
        }
        fetchSize = rows;
    }

    public int getFetchSize() throws SQLException {
        return fetchSize;
    }

    public int getResultSetConcurrency() throws SQLException {
        return concurrency;
    }

    public int getResultSetType() throws SQLException {
        return type;
    }

    public void addBatch(String sql) throws SQLException {
        batchStrings.add (sql);
    }

    public void clearBatch() throws SQLException {
        batchStrings.clear();
    }

    public Connection getConnection() throws SQLException {
        return connection;
    }

    public boolean getMoreResults(int current) throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    public ResultSet getGeneratedKeys() throws SQLException {
        // TODO
        if (autoGeneratedKeysResultSet == null) {
            // autoGeneratedKeysResultSet = new CUBRIDServerSideResultSet(null);
        }

        return autoGeneratedKeysResultSet;
    }

    public int[] executeBatch() throws SQLException {
        if (batchStrings.size() == 0)
        {
            return new int[0];
        }
        else
        {
            // send batch execute
            // set batch results

            clearBatch ();
            // check batch result
        }

        // TODO
        return null;
    }
    
    public ResultSet executeQuery(String sql) throws SQLException {
        // TODO
        long begin = 0;

        begin = System.currentTimeMillis();



        long end = System.currentTimeMillis();

        return currentResultSet;
    }
    
    public int executeUpdate(String sql) throws SQLException {
        return executeUpdate(sql, Statement.NO_GENERATED_KEYS);
    }

    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        // TODO
        return 0;
    }

    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return executeUpdate(sql, Statement.NO_GENERATED_KEYS);
    }

    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return executeUpdate(sql, Statement.NO_GENERATED_KEYS);
    }

    public boolean execute(String sql) throws SQLException {
        return execute(sql, Statement.NO_GENERATED_KEYS);
    }

    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        // TODO

        // 1) complete current ResultSet
        completeResultSet ();

        // 2) prepare
        prepareInternal(sql);

        // 3) execute

        // auto generated key argument affects only for INSERT query
        if (true) { // Is INSERT query
          this.autoGeneratedKeys = autoGeneratedKeys;

        }

        executeInternal ();



        // 4) get results

        return true;
    }

    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return execute(sql, Statement.NO_GENERATED_KEYS);
    }

    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return execute(sql, Statement.NO_GENERATED_KEYS);
    }

    public int getResultSetHoldability() throws SQLException {
        return holdable;
    }

    /* JDK 1.6 */
    public boolean isClosed() throws SQLException {
        return closed;
    }

    /* JDK 1.6 */
    public boolean isPoolable() throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.6 */
    public void setPoolable(boolean poolable) throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.6 */
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.6 */
    public <T> T unwrap(Class<T> iface) throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.7 */
    public void closeOnCompletion() throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.7 */
    public boolean isCloseOnCompletion() throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }
}
