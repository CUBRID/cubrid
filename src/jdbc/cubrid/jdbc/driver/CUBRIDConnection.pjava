/*
 * Copyright (C) 2008 Search Solution Corporation. All rights reserved by Search Solution. 
 *
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met: 
 *
 * - Redistributions of source code must retain the above copyright notice, 
 *   this list of conditions and the following disclaimer. 
 *
 * - Redistributions in binary form must reproduce the above copyright notice, 
 *   this list of conditions and the following disclaimer in the documentation 
 *   and/or other materials provided with the distribution. 
 *
 * - Neither the name of the <ORGANIZATION> nor the names of its contributors 
 *   may be used to endorse or promote products derived from this software without 
 *   specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
 * OF SUCH DAMAGE. 
 *
 */

package @CUBRID_DRIVER@;

import java.sql.*;
import java.util.*;
import java.io.*;

import @CUBRID_SQL@.*;
import @CUBRID_JCI@.*;
import @CUBRID_DRIVER@.*;

/**
 * Title: CUBRID JDBC Driver Description:
 * 
 * @version 2.0
 */

public class CUBRIDConnection implements Connection
{
  // Transaction Isolation Level Contants
  public static final int TRAN_REP_CLASS_REP_INSTANCE = TRANSACTION_REPEATABLE_READ;	// 4
  public static final int TRAN_REP_CLASS_COMMIT_INSTANCE = 16;
  public static final int TRAN_REP_CLASS_UNCOMMIT_INSTANCE = 32;
  public static final int TRAN_COMMIT_CLASS_COMMIT_INSTANCE = TRANSACTION_READ_COMMITTED;	// 2
  public static final int TRAN_COMMIT_CLASS_UNCOMMIT_INSTANCE = TRANSACTION_READ_UNCOMMITTED;	// 1
  public static final int TRAN_SERIALIZABLE = TRANSACTION_SERIALIZABLE;

  UConnection u_con;
  String user;
  String url;

  protected boolean is_closed;
  protected boolean auto_commit;

  private UError error;
  private boolean ending;

  private ArrayList statements;
  private CUBRIDDatabaseMetaData mdata;
  private boolean isServerSideJdbc;
  private ArrayList outRs;
  private boolean isAutoGeneratedKeys = false;

  /*
   * 3.0 ArrayList savepoints; int sv_count, sv_id; String sv_name; private
   * boolean isFromPooledCon=false; private CUBRIDPooledConnection
   * associatedPhysicalConnection = null;
   */

  protected CUBRIDConnection (UConnection u, String r, String s)
  {
    u_con = u;
    u_con.setCUBRIDConnection (this);
    url = r;
    user = s;
    is_closed = false;
    auto_commit = true;
    error = null;
    mdata = null;
    ending = false;
    statements = new ArrayList ();
    outRs = new ArrayList ();
    isServerSideJdbc = false;

    /*
     * 3.0 savepoints = new ArrayList(); sv_count = 0; sv_name = "";
     * isFromPooledCon = false;
     */
  }

  public CUBRIDConnection (UConnection u, String r, String s,
			   boolean isServerSideJdbc)
  {
    this (u, r, s);
    if (isServerSideJdbc)
      {
	this.auto_commit = false;
	this.isServerSideJdbc = true;
      }
  }

  /*
   * 3.0 CUBRIDConnection (UConnection u, String r, String s,
   * CUBRIDPooledConnection pcon) { u_con = u; url = r; user = s; is_closed =
   * false; auto_commit = true; error = null; mdata = null; ending = false;
   * statements = new ArrayList();
   * 
   * savepoints = new ArrayList(); sv_count = 0; sv_name = "";
   * 
   * isFromPooledCon = true; associatedPhysicalConnection = pcon; }
   */

  /*
   * java.sql.Connection interface
   */

  public synchronized Statement createStatement () throws SQLException
  {
    return createStatement (ResultSet.TYPE_FORWARD_ONLY,
			    ResultSet.CONCUR_READ_ONLY);
  }

  public synchronized PreparedStatement prepareStatement (String sql)
    throws SQLException
  {
    return prepare (sql, ResultSet.TYPE_FORWARD_ONLY,
		    ResultSet.CONCUR_READ_ONLY, Statement.NO_GENERATED_KEYS);
  }

  public synchronized CallableStatement prepareCall (String sql)
    throws SQLException
  {
    checkIsOpen ();
    UStatement us = prepare (sql, UConnection.PREPARE_CALL);
    CallableStatement cstmt = new CUBRIDCallableStatement (this, us);
      addStatement (cstmt);
      return cstmt;
  }

  public String nativeSQL (String sql) throws SQLException
  {
    throw new UnsupportedOperationException ();
  }

  public synchronized void setAutoCommit (boolean autoCommit)
    throws SQLException
  {
    checkIsOpen ();
    if (!isServerSideJdbc)
      {
	if (auto_commit != autoCommit)
	  commit ();
	auto_commit = autoCommit;
	u_con.setAutoCommit (autoCommit);

	/*
	 * Disabled Send to Broker for ServerSide AutoCommit synchronized(u_con){
	 * u_con.setAutoCommit(autoCommit); error = u_con.getRecentError(); }
	 * 
	 * switch (error.getErrorCode()){ case UErrorCode.ER_NO_ERROR: auto_commit
	 * = autoCommit; break; default: throw new CUBRIDException(error); } }
	 */

      }
  }

  public synchronized boolean getAutoCommit () throws SQLException
  {
    checkIsOpen ();
    return auto_commit;
  }

  public synchronized void commit () throws SQLException
  {
    checkIsOpen ();

    if (ending)
      return;
    ending = true;

    if (!isServerSideJdbc)
      {
	completeAllStatements ();

	try
	{
	  end (true);
	}
	finally
	{
	  ending = false;
	}
      }
    ending = false;

    /*
     * 3.0 clearSavepoint();
     */
  }

  public synchronized void rollback () throws SQLException
  {
    checkIsOpen ();

    if (ending)
      return;
    ending = true;

    if (!isServerSideJdbc)
      {
	completeAllStatements ();

	try
	{
	  end (false);
	}
	finally
	{
	  ending = false;
	}
      }
    ending = false;

    /*
     * 3.0 clearSavepoint();
     */
  }

  public synchronized void close () throws SQLException
  {
    if (is_closed)
      return;

    clear ();

    is_closed = true;

    /*
     * 3.0 if (!isFromPooledCon) u_con.close(); else
     * associatedPhysicalConnection.notifyConnectionClosed();
     */
    u_con.close ();

    u_con = null;
    url = null;
    user = null;
    mdata = null;
    statements = null;
    error = null;
  }

  public synchronized boolean isClosed () throws SQLException
  {
    return is_closed;
  }

  public synchronized DatabaseMetaData getMetaData () throws SQLException
  {
    checkIsOpen ();

    if (mdata != null)
      return mdata;

    mdata = new CUBRIDDatabaseMetaData (this);
    return mdata;
  }

  public synchronized void setReadOnly (boolean readOnly) throws SQLException
  {
    checkIsOpen ();
  }

  public synchronized boolean isReadOnly () throws SQLException
  {
    checkIsOpen ();
    return false;
  }

  public synchronized void setCatalog (String catalog) throws SQLException
  {
    checkIsOpen ();
  }

  public synchronized String getCatalog () throws SQLException
  {
    checkIsOpen ();
    return "";
  }

  public synchronized void setTransactionIsolation (int level)
    throws SQLException
  {
    checkIsOpen ();

    commit ();

    int uni_level;
    switch (level)
      {
      case TRANSACTION_READ_COMMITTED:
	uni_level = CUBRIDIsolationLevel.TRAN_COMMIT_CLASS_COMMIT_INSTANCE;
	break;
	case TRANSACTION_READ_UNCOMMITTED:uni_level =
	  CUBRIDIsolationLevel.TRAN_COMMIT_CLASS_UNCOMMIT_INSTANCE;
	break;
	case TRANSACTION_REPEATABLE_READ:uni_level =
	  CUBRIDIsolationLevel.TRAN_REP_CLASS_REP_INSTANCE;
	break;
	case TRANSACTION_SERIALIZABLE:
	  // uni_level = CUBRIDIsolationLevel.TRAN_REP_CLASS_REP_INSTANCE; cubrid
	  // 5.x
	uni_level = CUBRIDIsolationLevel.TRAN_SERIALIZABLE;
	break;
	case TRAN_REP_CLASS_COMMIT_INSTANCE:uni_level =
	  CUBRIDIsolationLevel.TRAN_REP_CLASS_COMMIT_INSTANCE;
	break;
	case TRAN_REP_CLASS_UNCOMMIT_INSTANCE:uni_level =
	  CUBRIDIsolationLevel.TRAN_REP_CLASS_UNCOMMIT_INSTANCE;
	break;
	default:throw new CUBRIDException (CUBRIDJDBCErrorCode.
					   invalid_trans_iso_level);
      }

    synchronized (u_con)
    {
      u_con.setIsolationLevel (uni_level);
      error = u_con.getRecentError ();
    }

    switch (error.getErrorCode ())
      {
      case UErrorCode.ER_NO_ERROR:
	break;
      default:
	throw new CUBRIDException (error);
      }
  }

  public synchronized int getTransactionIsolation () throws SQLException
  {
    checkIsOpen ();

    int uni_level = 0;
      synchronized (u_con)
    {
      uni_level = u_con.getIsolationLevel ();
      error = u_con.getRecentError ();
    }

    switch (error.getErrorCode ())
      {
      case UErrorCode.ER_NO_ERROR:
	break;
      default:
	throw new CUBRIDException (error);
      }

    switch (uni_level)
      {
      case CUBRIDIsolationLevel.TRAN_COMMIT_CLASS_COMMIT_INSTANCE:
	return TRAN_COMMIT_CLASS_COMMIT_INSTANCE;
      case CUBRIDIsolationLevel.TRAN_COMMIT_CLASS_UNCOMMIT_INSTANCE:
	return TRAN_COMMIT_CLASS_UNCOMMIT_INSTANCE;
      case CUBRIDIsolationLevel.TRAN_REP_CLASS_REP_INSTANCE:
	return TRAN_REP_CLASS_REP_INSTANCE;
      case CUBRIDIsolationLevel.TRAN_REP_CLASS_COMMIT_INSTANCE:
	return TRAN_REP_CLASS_COMMIT_INSTANCE;
      case CUBRIDIsolationLevel.TRAN_REP_CLASS_UNCOMMIT_INSTANCE:
	return TRAN_REP_CLASS_UNCOMMIT_INSTANCE;
      case CUBRIDIsolationLevel.TRAN_SERIALIZABLE:
	return TRAN_SERIALIZABLE;
      default:
	return 0;
      }
  }

  public synchronized SQLWarning getWarnings () throws SQLException
  {
    checkIsOpen ();
    return null;
  }

  public synchronized void clearWarnings () throws SQLException
  {
    checkIsOpen ();
  }

  public synchronized Statement createStatement (int resultSetType,
						 int resultSetConcurrency)
    throws SQLException
  {
    checkIsOpen ();
    Statement stmt = new CUBRIDStatement (this, resultSetType,
					  resultSetConcurrency);
      addStatement (stmt);
      return stmt;
  }

  public synchronized PreparedStatement prepareStatement (String sql,
							  int resultSetType,
							  int
							  resultSetConcurrency)
    throws SQLException
  {
    return prepare (sql, resultSetType, resultSetConcurrency,
		    Statement.NO_GENERATED_KEYS);
  }

  public CallableStatement prepareCall (String sql, int resultSetType,
					int resultSetConcurrency) throws
    SQLException
  {
    return (prepareCall (sql));
  }

  public Map getTypeMap () throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

  public void setTypeMap (Map map) throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

  // 3.0 api
  public synchronized Statement createStatement (int type, int concur,
						 int holdable) throws
    SQLException
  {
    // hold = holdable;
    return createStatement (type, concur);
  }

  public synchronized int getHoldability () throws SQLException
  {
    return ResultSet.CLOSE_CURSORS_AT_COMMIT;
  }

  public CallableStatement prepareCall (String sql, int type, int concur,
					int holdable) throws SQLException
  {
    return (prepareCall (sql));
  }

  public synchronized PreparedStatement prepareStatement (String sql,
							  int
							  autoGeneratedKeys)
    throws SQLException
  {
    return prepare (sql, ResultSet.TYPE_FORWARD_ONLY,
		    ResultSet.CONCUR_READ_ONLY, autoGeneratedKeys);
  }

  public synchronized PreparedStatement prepareStatement (String sql,
							  int type,
							  int concur,
							  int holdable) throws
    SQLException
  {
    // hold = holdable;
    return prepareStatement (sql, type, concur);
  }

  public synchronized PreparedStatement prepareStatement (String sql,
							  int[]indexes) throws
    SQLException
  {
    // auto = Statement.RETURN_GENERATED_KEYS;
    return prepareStatement (sql);
  }

  public synchronized PreparedStatement prepareStatement (String sql,
							  String[]colName)
    throws SQLException
  {
    // auto = Statement.RETURN_GENERATED_KEYS;
    return prepareStatement (sql);
  }

  public synchronized void releaseSavepoint (Savepoint savepoint)
    throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
    /*
     * 3.0 checkIsOpen(); boolean flag=true;
     * 
     * if (!savepoints.isEmpty()) { for (int i=0 ; i < savepoints.size() ; i++)
     * {
     * if(savepoint.equals(((CUBRIDSavepoint)savepoints.get(i)).getSavepointName
     * ())) { savepoints.remove(savepoint); flag=false; } } }
     * 
     * if (flag) throw new CUBRIDException("The Savepoint is not exist ");
     */
  }

  public synchronized void rollback (Savepoint savepoint) throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
    /*
     * 3.0 checkIsOpen();
     * 
     * if (isRelease((CUBRIDSavepoint)savepoint)) { throw new
     * CUBRIDException("The Savepoint is released"); }
     * 
     * synchronized (u_con) { u_con.savepoint(2, savepoint.getSavepointName());
     * error = u_con.getRecentError(); }
     * 
     * switch (error.getErrorCode()) { case UErrorCode.ER_NO_ERROR : break;
     * default : throw new CUBRIDException(error); }
     * 
     * //rollback된 savepoint이전에 설정된것들 삭제하는 루틴
     * deleteSavepoint((CUBRIDSavepoint)savepoint);
     */
  }

  public synchronized void setHoldability (int holdable) throws SQLException
  {
    // hold = holdable;
  }

  public synchronized Savepoint setSavepoint () throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
    /*
     * 3.0 checkIsOpen();
     * 
     * sv_id = createSavepointId(); // sv_name = name;
     * 
     * if (sv_name.length() == 0) sv_name = createSavepointName(); else if
     * (existName(sv_name)) throw new
     * CUBRIDException("The Savepoint name "+sv_name+" exist");
     * 
     * synchronized (u_con) { u_con.savepoint(1, sv_name); error =
     * u_con.getRecentError(); }
     * 
     * switch (error.getErrorCode()) { case UErrorCode.ER_NO_ERROR : break;
     * default : throw new CUBRIDException(error); } Savepoint sv = new
     * CUBRIDSavepoint(this, sv_name, sv_id); savepoints.add(sv); sv_name = "";
     * sv_id = 0; return sv;
     */
  }

  public synchronized Savepoint setSavepoint (String name) throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
    /*
     * 3.0 checkIsOpen(); sv_name = name;
     * 
     * if (existName(sv_name)) throw new
     * CUBRIDException("The Savepoint name "+sv_name+" exist");
     * 
     * return setSavepoint();
     */
  }

  // 3.0 api

  synchronized public void setCharset (String charsetName)
    throws java.io.UnsupportedEncodingException
  {
    u_con.setCharset (charsetName);
  }

  public synchronized CUBRIDOID getNewGLO (String className,
					   InputStream stream) throws
    SQLException
  {
    checkIsOpen ();

    CUBRIDOID oid = newGloLo (className);
      oid.saveGLO (stream);
      return oid;
  }

  public synchronized CUBRIDOID getNewGLO (String className,
					   InputStream stream,
					   int length) throws SQLException
  {
    checkIsOpen ();

    CUBRIDOID oid = newGloLo (className);
      oid.saveGLO (stream, length);
      return oid;
  }

  public synchronized CUBRIDOID newGloLo (String className) throws
    SQLException
  {
    return (newGlo (className, UConnection.GLO_NEW_TYPE_LO, null));
  }

  public synchronized CUBRIDOID newGloFbo (String className, String filename)
    throws SQLException
  {
    return (newGlo (className, UConnection.GLO_NEW_TYPE_FBO, filename));
  }

  public synchronized CUBRIDConnectionKey Login (String SignedData)
    throws SQLException
  {
    return null;
  }

  public synchronized CUBRIDConnectionKey Login (byte[]SignedData)
    throws SQLException
  {
    return null;
  }

  public void Logout ()
  {
  }

  public void SetSignedConnection ()
  {
  }

  public synchronized UConnection getUConnection () throws SQLException
  {
    checkIsOpen ();
    return u_con;
  }

  public synchronized void setLockTimeout (int timeout) throws SQLException
  {
    checkIsOpen ();

    synchronized (u_con)
    {
      u_con.setLockTimeout (timeout);
      error = u_con.getRecentError ();
    }

    switch (error.getErrorCode ())
      {
      case UErrorCode.ER_NO_ERROR:
	break;
      default:
	throw new CUBRIDException (error);
      }
  }

  public void setAutoGeneratedKeys(boolean isGeneratedKeys){
    isAutoGeneratedKeys = isGeneratedKeys;
  }

  UStatement prepare(String sql, byte prepareFlag) throws SQLException
  {
    UStatement us = null;

      synchronized (u_con)
    {
      us = u_con.prepare (sql, prepareFlag);
      error = u_con.getRecentError ();
    }

    switch (error.getErrorCode ())
      {
      case UErrorCode.ER_NO_ERROR:
	return us;
      default:
	UError cpErr = new UError (error);
	autoRollback ();
	throw new CUBRIDException (cpErr);
      }
  }

  void autoCommit () throws SQLException
  {
    checkIsOpen ();
    if (auto_commit)
      commit ();
  }

  void autoRollback () throws SQLException
  {
    checkIsOpen ();
    if (auto_commit)
      rollback ();
  }

  synchronized void closeConnection () throws SQLException
  {
    if (is_closed)
      return;

    clear ();

    is_closed = true;
  }

  synchronized void removeStatement (Statement s) throws SQLException
  {
    int i = statements.indexOf (s);
    if (i > -1)
        statements.remove (i);
  }

  private void clear () throws SQLException
  {
    closeAllStatements ();
    closeAllOutResultSet ();

    if (mdata != null)
      mdata.close ();
    mdata = null;
  }

  private void checkIsOpen () throws SQLException
  {
    if (is_closed)
      {
	throw new CUBRIDException (CUBRIDJDBCErrorCode.connection_closed);
      }
  }

  private void addStatement (Statement s) throws SQLException
  {
    statements.add (s);
  }

  private void completeAllStatements () throws SQLException
  {
    for (int i = 0; i < statements.size (); i++)
      {
	CUBRIDStatement stmt = (CUBRIDStatement) statements.get (i);
	if (stmt instanceof CUBRIDPreparedStatement)
	  {

	    statements.remove (i);
	    if (u_con.brokerInfoStatementPooling () == true)
	      stmt.complete ();
	    else
	      stmt.close ();
	  }
	else
	    stmt.complete ();
      }
  }

  private void closeAllStatements () throws SQLException
  {
    for (int i = 0; i < statements.size (); i++)
      {
	CUBRIDStatement stmt = (CUBRIDStatement) statements.get (i);
	  stmt.close ();
      }
    statements.clear ();
  }

  private void closeAllOutResultSet () throws SQLException
  {
    for (int i = 0; i < outRs.size (); i++)
      {
	CUBRIDOutResultSet rs = (CUBRIDOutResultSet) outRs.get (i);
	  rs.close ();
      }
    outRs.clear ();
  }

  public void addOutResultSet (CUBRIDOutResultSet rs)
  {
    outRs.add (rs);
  }

#ifdef JDK6
/* JDK 1.6 */
  public Array createArrayOf (String arg0, Object[]arg1) throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

/* JDK 1.6 */
  public Blob createBlob () throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

/* JDK 1.6 */
  public Clob createClob () throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

/* JDK 1.6 */
  public NClob createNClob () throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

/* JDK 1.6 */
  public SQLXML createSQLXML () throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

/* JDK 1.6 */
  public Struct createStruct (String arg0, Object[]arg1) throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

/* JDK 1.6 */
  public Properties getClientInfo () throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

/* JDK 1.6 */
  public String getClientInfo (String arg0) throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

/* JDK 1.6 */
  public boolean isValid (int arg0) throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

/* JDK 1.6 */
  public void setClientInfo (Properties arg0) throws SQLClientInfoException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

/* JDK 1.6 */
  public void setClientInfo (String arg0, String arg1)
    throws SQLClientInfoException
  {
    throw new java.lang.UnsupportedOperationException ();
  }
/* JDK 1.6 */
  public boolean isWrapperFor (Class < ? >arg0) throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }

/* JDK 1.6 */
  public < T > T unwrap (Class < T > arg0) throws SQLException
  {
    throw new java.lang.UnsupportedOperationException ();
  }
#endif

  private void end (boolean commit) throws SQLException
  {
    synchronized (u_con)
    {
      if ( isAutoGeneratedKeys ){
    	  u_con.turnOnAutoCommitBySelf();
      }
      u_con.endTransaction(commit);
      
      error = u_con.getRecentError();
    }

    switch (error.getErrorCode ())
      {
      case UErrorCode.ER_NO_ERROR:
	break;
      default:
	throw new CUBRIDException (error);
      }
  }

  private CUBRIDOID newGlo (String className, byte type, String filename)
    throws SQLException
  {
    checkIsOpen ();

    CUBRIDOID oid = null;
      synchronized (u_con)
    {
      oid = u_con.gloNew (className, type, filename);
      error = u_con.getRecentError ();
    }

    switch (error.getErrorCode ())
      {
      case UErrorCode.ER_NO_ERROR:
	break;
      default:
	throw new CUBRIDException (error);
      }

    return oid;
  }

  private PreparedStatement prepare (String sql, int resultSetType,
				     int resultSetConcurrency,
				     int autoGeneratedKeys) throws
    SQLException
  {
    checkIsOpen ();

    byte prepareFlag = (byte) 0;

    if (resultSetType == ResultSet.TYPE_SCROLL_SENSITIVE
	|| resultSetConcurrency == ResultSet.CONCUR_UPDATABLE)
      {
	prepareFlag = UConnection.PREPARE_UPDATABLE;
      }

    UStatement us = prepare (sql, prepareFlag);
    PreparedStatement pstmt = new CUBRIDPreparedStatement (this, us,
							   resultSetType,
							   resultSetConcurrency,
							   autoGeneratedKeys);
    addStatement (pstmt);
    return pstmt;
  }

  /*
   * 3.0 private int createSavepointId() throws SQLException { int tempid=0; do
   * { Random r = new Random(); tempid = Math.abs(r.nextInt()) % 1000000 + 1; }
   * while(existId(tempid)); return tempid; }
   * 
   * private String createSavepointName() { String tempname; tempname =
   * "UNISV_"+sv_id; return tempname; }
   * 
   * private boolean existId(int tid) throws SQLException { if
   * (!savepoints.isEmpty()) { for (int i=0; i < savepoints.size(); i++) { if
   * (tid == ((CUBRIDSavepoint)savepoints.get(i)).getSavepointId()) return true;
   * } }
   * 
   * return false; }
   * 
   * private boolean existName(String name) throws SQLException { if
   * (!savepoints.isEmpty()) { for (int i=0 ; i < savepoints.size() ; i++) { if
   * (name.equals(((CUBRIDSavepoint)savepoints.get(i)).getSavepointName()))
   * return true; } } return false; }
   * 
   * private boolean isRelease(CUBRIDSavepoint sv) { boolean flag = true;
   * 
   * for (int i=0 ; i <savepoints.size() ; i++) {
   * if(((CUBRIDSavepoint)savepoints.get(i)).equals(sv)) { flag = false; break;
   * } } return flag; }
   * 
   * private synchronized void deleteSavepoint(CUBRIDSavepoint sv) { int index;
   * index = savepoints.indexOf(sv);
   * 
   * for(int j = index; j < savepoints.size();) savepoints.remove(j); }
   * 
   * private synchronized void clearSavepoint() { savepoints.clear(); }
   */

  protected void finalize ()
  {
    try
    {
      close ();
    }
    catch (Exception e)
    {
    }
  }
}
