/*
 * Copyright (C) 2008 Search Solution Corporation.
 * Copyright (c) 2016 CUBRID Corporation.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * - Neither the name of the <ORGANIZATION> nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 */

package com.cubrid.jsp.jdbc;

import com.cubrid.jsp.exception.TypeMismatchException;
import com.cubrid.jsp.impl.SUStatement;
import cubrid.jdbc.jci.CUBRIDCommandType;
import cubrid.sql.CUBRIDOID;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.LinkedList;

public class CUBRIDServerSideStatement implements Statement {

    protected CUBRIDServerSideConnection connection = null;

    protected int type; // ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE,
    // ResultSet.TYPE_SCROLL_SENSITIVE
    protected int concurrency; // ResultSet.CONCUR_READ_ONLY, ResultSet.CONCUR_UPDATABLE
    protected int holdable; // ResultSet.HOLD_CURSORS_OVER_COMMIT, ResultSet.CLOSE_CURSORS_AT_COMMIT

    protected int autoGeneratedKeys; // Statement.NO_GENERATED_KEYS, Statement.RETURN_GENERATED_KEYS
    protected int fetchSize;
    protected int fetchDirection;
    protected boolean closed;
    protected int maxRows;
    protected int maxFieldSize;

    protected LinkedList<String> batchStrings;
    protected CUBRIDServerSideResultSet currentResultSet;
    protected CUBRIDServerSideResultSet autoGeneratedKeysResultSet;

    protected SUStatement statementHandler;
    protected SUStatement autoGeneratedKeysHandler;

    protected int updateCount; // for getUpdateCount (), # of afftected by a query

    protected CUBRIDServerSideStatement(
            CUBRIDServerSideConnection con, int type, int concurrency, int holdable) {
        this.connection = con;
        this.type = type;
        this.concurrency = concurrency;
        this.holdable = holdable;

        fetchSize = 0;
        fetchDirection = ResultSet.FETCH_FORWARD;
        maxRows = 0;
        maxFieldSize = 0;
        updateCount = -1;

        closed = false;
        currentResultSet = null;

        autoGeneratedKeys = Statement.NO_GENERATED_KEYS;
        autoGeneratedKeysResultSet = null;

        this.batchStrings = new LinkedList<String>();
    }

    public SUStatement getStatementHandler() {
        return statementHandler;
    }

    protected void prepareInternal(String sql) throws SQLException, IOException {
        byte prepareFlag = (byte) 0;
        if (isUpdatable() || isSensitive()) {
            prepareFlag |= CUBRIDServerSideConstants.PREPARE_UPDATABLE;
        }

        /*
         * NOTE: unsupported query_info and holdable cursor in server-side JDBC if
         * (false) { // query info prepareFlag |=
         * CUBRIDServerSideConstants.PREPARE_QUERY_INFO; } if (false) { // is_holdable
         * prepareFlag |= CUBRIDServerSideConstants.PREPARE_HOLDABLE; }
         */

        statementHandler = connection.getSUConnection().prepare(sql, prepareFlag, false);
    }

    protected void executeInternal() throws IOException, SQLException {
        statementHandler.execute(maxRows, maxFieldSize, isSensitive(), isScrollable());
    }

    protected void completeResultSet() throws SQLException {
        if (currentResultSet != null) {
            currentResultSet.close();
            currentResultSet = null;
        }
    }

    protected boolean makeAutoGeneratedKeysResultSet() throws SQLException {
        if (autoGeneratedKeysResultSet != null) {
            autoGeneratedKeysResultSet.close();
            autoGeneratedKeysResultSet = null;
        }

        try {
            autoGeneratedKeysHandler =
                    connection.getSUConnection().getGeneratedKeys(statementHandler.getHandlerId());
            autoGeneratedKeysResultSet = new CUBRIDServerSideResultSet(autoGeneratedKeysHandler);
            return true;
        } catch (IOException e) {
            return false;
        } catch (TypeMismatchException e) {
            return false;
        }
    }

    protected void resetGeneratedKeysResultSet() throws SQLException {
        if (autoGeneratedKeysResultSet != null) {
            autoGeneratedKeysResultSet.close();
            autoGeneratedKeysResultSet = null;
        }

        /* it will reset at autoGeneratedKeysResultSet.close(); */
        autoGeneratedKeysHandler = null;
    }

    private void checkIsScrollable() throws SQLException {
        // TODO: scrollable is not implemented yet
        throw new SQLException(new UnsupportedOperationException());
    }

    // ==============================================================
    // The following is JDBC Interface Implementations
    // ==============================================================

    @Override
    public void close() throws SQLException {
        if (isClosed() == false) {
            closed = true;
            completeResultSet();
            connection = null; // detach with connection
        }
    }

    @Override
    public int getMaxFieldSize() throws SQLException {
        return maxFieldSize;
    }

    @Override
    public void setMaxFieldSize(int max) throws SQLException {
        if (max < 0) {
            throw new IllegalArgumentException();
        }
        maxFieldSize = max;
    }

    @Override
    public int getMaxRows() throws SQLException {
        return maxRows;
    }

    @Override
    public void setMaxRows(int max) throws SQLException {
        if (max < 0) {
            throw new IllegalArgumentException();
        }
        maxRows = max;
    }

    @Override
    public void setEscapeProcessing(boolean enable) throws SQLException {
        /* do nothing */
    }

    @Override
    public int getQueryTimeout() throws SQLException {
        /* do nothing, returns default value */
        return 0;
    }

    @Override
    public void setQueryTimeout(int seconds) throws SQLException {
        final int MAX_QUERY_TIMEOUT = 2000000; // compatbile with client side
        if (seconds < 0 || seconds > MAX_QUERY_TIMEOUT) {
            throw new IllegalArgumentException();
        }

        /* do nothing */
    }

    @Override
    public void cancel() throws SQLException {
        // NOTE: I'm not sure that this has to be supported
        /* do nothing */
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        /* do nothing */
        return null;
    }

    @Override
    public void clearWarnings() throws SQLException {
        /* do nothing */
    }

    @Override
    public void setCursorName(String name) throws SQLException {
        /* do nothing */
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        return currentResultSet;
    }

    @Override
    public int getUpdateCount() throws SQLException {
        return updateCount;
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        // 1) complete
        completeResultSet();

        // 2) create ResultSet
        boolean isResultType = statementHandler.getResultInfo().isReusltSet();
        if (isResultType) {
            int resultSetType = this.type;
            int resultSetConcurrency = this.concurrency;
            if (isSensitive() && statementHandler.isOIDIncluded() == false) {
                resultSetType = ResultSet.TYPE_SCROLL_INSENSITIVE;
            }
            if (isUpdatable() && statementHandler.isOIDIncluded() == false) {
                resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
            }
            currentResultSet =
                    new CUBRIDServerSideResultSet(
                            this.connection, this, resultSetType, resultSetConcurrency);
            updateCount = -1;
        } else {
            updateCount = statementHandler.getResultInfo().getResultCount();
        }

        return isResultType;
    }

    protected boolean isSensitive() {
        return (type == ResultSet.TYPE_SCROLL_SENSITIVE);
    }

    protected boolean isUpdatable() throws SQLException {
        return (getResultSetConcurrency() == ResultSet.CONCUR_UPDATABLE);
    }

    protected boolean isScrollable() {
        return (type != ResultSet.TYPE_FORWARD_ONLY);
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {
        checkIsScrollable();
        switch (direction) {
            case ResultSet.FETCH_FORWARD:
            case ResultSet.FETCH_REVERSE:
            case ResultSet.FETCH_UNKNOWN:
                fetchDirection = direction;
                break;
            default:
                throw new IllegalArgumentException();
        }
    }

    @Override
    public int getFetchDirection() throws SQLException {
        return fetchDirection;
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {
        if (rows < 0) {
            throw new IllegalArgumentException();
        }
        fetchSize = rows;
    }

    @Override
    public int getFetchSize() throws SQLException {
        return fetchSize;
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        return concurrency;
    }

    @Override
    public int getResultSetType() throws SQLException {
        return type;
    }

    @Override
    public void addBatch(String sql) throws SQLException {
        // TODO: not implemented yet
        // batchStrings.add (sql);
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    @Override
    public void clearBatch() throws SQLException {
        // TODO: not implemented yet
        // batchStrings.clear();
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    @Override
    public Connection getConnection() throws SQLException {
        return connection;
    }

    @Override
    public boolean getMoreResults(int current) throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        if (autoGeneratedKeysResultSet == null) {
            /* empty ResultSet */
            autoGeneratedKeysResultSet = new CUBRIDServerSideResultSet(null);
        }

        return autoGeneratedKeysResultSet;
    }

    @Override
    public int[] executeBatch() throws SQLException {
        // TODO: not implemented yet
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        try {
            // 1) complete previous resultSet
            completeResultSet();

            // 2) prepare
            prepareInternal(sql);

            // 3) check SQL Type (SELECT, CALL, GET_STATS, EVALUATE)
            if (statementHandler.getSQLType() == false) {
                // statementHandler.close()?
                statementHandler = null;
                throw CUBRIDServerSideJDBCErrorManager.createCUBRIDException(
                        CUBRIDServerSideJDBCErrorCode.ER_INVALID_QUERY_TYPE_FOR_EXECUTEQUERY, null);
            }

            // 4) execute
            executeInternal();

            // 5) make resultSet
            getMoreResults();

            if (this.autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS
                    && statementHandler.getStatementType()
                            == CUBRIDCommandType.CUBRID_STMT_INSERT) {
                statementHandler.setAutoGeneratedKeys(true);
            }

        } catch (IOException e) {
            throw CUBRIDServerSideJDBCErrorManager.createCUBRIDException(
                    CUBRIDServerSideJDBCErrorCode.ER_COMMUNICATION, e);
        }

        return currentResultSet;
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        return executeUpdate(sql, Statement.NO_GENERATED_KEYS);
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        try {
            // 1) complete previous resultSet
            completeResultSet();

            // 2) prepare
            prepareInternal(sql);

            // 3) check SQL Type (SELECT, CALL, GET_STATS, EVALUATE)
            if (statementHandler.getSQLType() == true) {
                // statementHandler.close();?
                statementHandler = null;
                throw CUBRIDServerSideJDBCErrorManager.createCUBRIDException(
                        CUBRIDServerSideJDBCErrorCode.ER_INVALID_QUERY_TYPE_FOR_EXECUTEUPDATE,
                        null);
            }

            // 4) set autoGeneratedKeys
            this.autoGeneratedKeys = autoGeneratedKeys;
            if (this.autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS
                    && statementHandler.getStatementType()
                            == CUBRIDCommandType.CUBRID_STMT_INSERT) {
                statementHandler.setAutoGeneratedKeys(true);
            }

            // 5) execute
            executeInternal();

            // 6) make auto generated keys resultset
            if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS
                    && statementHandler.getStatementType()
                            == CUBRIDCommandType.CUBRID_STMT_INSERT) {
                makeAutoGeneratedKeysResultSet();
            } else {
                resetGeneratedKeysResultSet();
            }

            // 7) make make resultSet
            getMoreResults();
            return updateCount;
        } catch (IOException e) {
            e.printStackTrace();
        }

        return 0;
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return executeUpdate(sql, Statement.NO_GENERATED_KEYS);
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return executeUpdate(sql, Statement.NO_GENERATED_KEYS);
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        return execute(sql, Statement.NO_GENERATED_KEYS);
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        try {
            // 1) complete previous resultSet
            completeResultSet();

            // 2) prepare
            prepareInternal(sql);

            // 3) set autoGeneratedKeys
            this.autoGeneratedKeys = autoGeneratedKeys;
            if (this.autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS
                    && statementHandler.getStatementType()
                            == CUBRIDCommandType.CUBRID_STMT_INSERT) {
                statementHandler.setAutoGeneratedKeys(true);
            }

            // 4) execute
            executeInternal();

            // 5) make auto generated keys resultset
            if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS
                    && statementHandler.getStatementType()
                            == CUBRIDCommandType.CUBRID_STMT_INSERT) {
                makeAutoGeneratedKeysResultSet();
            } else {
                resetGeneratedKeysResultSet();
            }

            // 6) make resultSet
            return getMoreResults();
        } catch (IOException e) {
            throw CUBRIDServerSideJDBCErrorManager.createCUBRIDException(
                    CUBRIDServerSideJDBCErrorCode.ER_COMMUNICATION, e);
        }
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return execute(sql, Statement.NO_GENERATED_KEYS);
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return execute(sql, Statement.NO_GENERATED_KEYS);
    }

    /**
     * Executes an SQL <code>INSERT</code> statement and returns a <code>CUBRIDOID</code> object
     * that represents the OID of the object inserted by the given query.
     *
     * @param sql an SQL <code>INSERT</code> statement
     * @return a <code>CUBRIDOID</code> object that represents the OID of the object inserted by the
     *     given query.
     * @exception SQLException if <code>this</code> object is closed.
     * @exception IllegalArgumentException if <code>sql</code> is <code>null</code>.
     * @exception SQLException if <code>sql</code> is not an SQL <code>INSERT</code> statement.
     * @exception SQLException if a database access error occurs
     */
    public CUBRIDOID executeInsert(String sql) throws SQLException {
        try {
            // 1) complete previous resultSet
            completeResultSet();

            // 2) prepare
            prepareInternal(sql);

            // 3) set autoGeneratedKeys
            if (this.autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS
                    && statementHandler.getStatementType()
                            == CUBRIDCommandType.CUBRID_STMT_INSERT) {
                statementHandler.setAutoGeneratedKeys(true);
            }

            CUBRIDOID oid = statementHandler.executeInsert(this.connection);
            // completeResultSet();
            return oid;
        } catch (IOException e) {
            throw CUBRIDServerSideJDBCErrorManager.createCUBRIDException(
                    CUBRIDServerSideJDBCErrorCode.ER_COMMUNICATION, e);
        }
    }

    @Override
    public int getResultSetHoldability() throws SQLException {
        return holdable;
    }

    /* JDK 1.6 */
    @Override
    public boolean isClosed() throws SQLException {
        return closed;
    }

    /* JDK 1.6 */
    @Override
    public boolean isPoolable() throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.6 */
    @Override
    public void setPoolable(boolean poolable) throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.6 */
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.6 */
    public <T> T unwrap(Class<T> iface) throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.7 */
    @Override
    public void closeOnCompletion() throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }

    /* JDK 1.7 */
    @Override
    public boolean isCloseOnCompletion() throws SQLException {
        throw new SQLException(new java.lang.UnsupportedOperationException());
    }
}
